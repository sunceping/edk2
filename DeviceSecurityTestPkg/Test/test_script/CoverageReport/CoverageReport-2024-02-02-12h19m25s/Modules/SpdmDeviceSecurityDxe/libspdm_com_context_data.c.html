<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>libspdm_com_context_data.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/**
 *  Copyright Notice:
 *  Copyright 2021-2022 DMTF. All rights reserved.
 *  License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libspdm/blob/main/LICENSE.md
 **/

#include "internal/libspdm_common_lib.h"
#include "internal/libspdm_secured_message_lib.h"
#include "internal/libspdm_fips_lib.h"

#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
/* first section */
uint32_t libspdm_get_scratch_buffer_secure_message_offset(libspdm_context_t *spdm_context) {
    return 0;
}

uint32_t libspdm_get_scratch_buffer_secure_message_capacity(libspdm_context_t *spdm_context) {
    return spdm_context-&gt;local_context.capability.max_spdm_msg_size +
           spdm_context-&gt;local_context.capability.transport_header_size +
           spdm_context-&gt;local_context.capability.transport_tail_size;
}

/* second section */
uint32_t libspdm_get_scratch_buffer_large_message_offset(libspdm_context_t *spdm_context) {
    return libspdm_get_scratch_buffer_secure_message_capacity(spdm_context);
}

uint32_t libspdm_get_scratch_buffer_large_message_capacity(libspdm_context_t *spdm_context) {
    return spdm_context-&gt;local_context.capability.max_spdm_msg_size;
}
#endif

/* third section */
uint32_t libspdm_get_scratch_buffer_sender_receiver_offset(libspdm_context_t *spdm_context) {
    return 0 +
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
           libspdm_get_scratch_buffer_secure_message_capacity(spdm_context) +
           libspdm_get_scratch_buffer_large_message_capacity(spdm_context) +
#endif
           0;
}

<span style = "background-color:#dfd">uint32_t libspdm_get_scratch_buffer_sender_receiver_capacity(libspdm_context_t *spdm_context) {
    return spdm_context-&gt;local_context.capability.max_spdm_msg_size +</span>
           spdm_context-&gt;local_context.capability.transport_header_size +
           spdm_context-&gt;local_context.capability.transport_tail_size;
<span style = "background-color:#dfd">}</span>

#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
/* fourth section */
uint32_t libspdm_get_scratch_buffer_large_sender_receiver_offset(libspdm_context_t *spdm_context) {
    return libspdm_get_scratch_buffer_secure_message_capacity(spdm_context) +
           libspdm_get_scratch_buffer_large_message_capacity(spdm_context) +
           libspdm_get_scratch_buffer_sender_receiver_capacity(spdm_context);
}

uint32_t libspdm_get_scratch_buffer_large_sender_receiver_capacity(libspdm_context_t *spdm_context)
{
    return spdm_context-&gt;local_context.capability.max_spdm_msg_size +
           spdm_context-&gt;local_context.capability.transport_header_size +
           spdm_context-&gt;local_context.capability.transport_tail_size;
}
#endif

/* fifth section */
<span style = "background-color:#dfd">uint32_t libspdm_get_scratch_buffer_last_spdm_request_offset(libspdm_context_t *spdm_context) {
    return 0 +</span>
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
           libspdm_get_scratch_buffer_secure_message_capacity(spdm_context) +
           libspdm_get_scratch_buffer_large_message_capacity(spdm_context) +
#endif
           libspdm_get_scratch_buffer_sender_receiver_capacity(spdm_context) +
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
           libspdm_get_scratch_buffer_large_sender_receiver_capacity(spdm_context) +
#endif
           0;
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">uint32_t libspdm_get_scratch_buffer_last_spdm_request_capacity(libspdm_context_t *spdm_context) {
    return spdm_context-&gt;local_context.capability.max_spdm_msg_size;
}</span>

#if LIBSPDM_RESPOND_IF_READY_SUPPORT
/* sixth section */
<span style = "background-color:#dfd">uint32_t libspdm_get_scratch_buffer_cache_spdm_request_offset(libspdm_context_t *spdm_context) {
    return 0 +</span>
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
           libspdm_get_scratch_buffer_secure_message_capacity(spdm_context) +
           libspdm_get_scratch_buffer_large_message_capacity(spdm_context) +
#endif
           libspdm_get_scratch_buffer_sender_receiver_capacity(spdm_context) +
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
           libspdm_get_scratch_buffer_large_sender_receiver_capacity(spdm_context) +
#endif
           libspdm_get_scratch_buffer_last_spdm_request_capacity(spdm_context) +
           0;
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">uint32_t libspdm_get_scratch_buffer_cache_spdm_request_capacity(libspdm_context_t *spdm_context) {
    return spdm_context-&gt;local_context.capability.max_spdm_msg_size;
}</span>
#endif

/* combination */
<span style = "background-color:#dfd">uint32_t libspdm_get_scratch_buffer_capacity(libspdm_context_t *spdm_context) {
    return 0 +</span>
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
           libspdm_get_scratch_buffer_secure_message_capacity(spdm_context) +
           libspdm_get_scratch_buffer_large_message_capacity(spdm_context) +
#endif
           libspdm_get_scratch_buffer_sender_receiver_capacity(spdm_context) +
#if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
           libspdm_get_scratch_buffer_large_sender_receiver_capacity(spdm_context) +
#endif
           libspdm_get_scratch_buffer_last_spdm_request_capacity(spdm_context) +
#if LIBSPDM_RESPOND_IF_READY_SUPPORT
           libspdm_get_scratch_buffer_cache_spdm_request_capacity(spdm_context) +
#endif
           0;
<span style = "background-color:#dfd">}</span>

/**
 * Returns if an SPDM data_type requires session info.
 *
 * @param data_type  SPDM data type.
 *
 * @retval true  session info is required.
 * @retval false session info is not required.
 **/
static bool need_session_info_for_data(libspdm_data_type_t data_type)
<span style = "background-color:#dfd">{
    switch (data_type) {</span>
    case LIBSPDM_DATA_SESSION_USE_PSK:
    case LIBSPDM_DATA_SESSION_MUT_AUTH_REQUESTED:
    case LIBSPDM_DATA_SESSION_END_SESSION_ATTRIBUTES:
    case LIBSPDM_DATA_SESSION_POLICY:
    case LIBSPDM_DATA_SESSION_SEQUENCE_NUMBER_RSP_DIR:
    case LIBSPDM_DATA_SESSION_SEQUENCE_NUMBER_REQ_DIR:
    case LIBSPDM_DATA_SESSION_SEQUENCE_NUMBER_ENDIAN:
<span style = "background-color:#fdd">        return true;</span>
    default:
<span style = "background-color:#dfd">        return false;</span>
    }
<span style = "background-color:#dfd">}</span>

/**
 * Set an SPDM context data.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  data_type                     Type of the SPDM context data.
 * @param  parameter                    Type specific parameter of the SPDM context data.
 * @param  data                         A pointer to the SPDM context data.
 * @param  data_size                     size in bytes of the SPDM context data.
 *
 * @retval RETURN_SUCCESS               The SPDM context data is set successfully.
 * @retval RETURN_INVALID_PARAMETER     The data is NULL or the data_type is zero.
 * @retval RETURN_UNSUPPORTED           The data_type is unsupported.
 * @retval RETURN_ACCESS_DENIED         The data_type cannot be set.
 * @retval RETURN_NOT_READY             data is not ready to set.
 **/
libspdm_return_t libspdm_set_data(void *spdm_context, libspdm_data_type_t data_type,
                                  const libspdm_data_parameter_t *parameter, void *data,
                                  size_t data_size)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    uint32_t session_id;
    uint32_t data32;
    libspdm_session_info_t *session_info;
    uint8_t slot_id;
    uint8_t mut_auth_requested;
    uint8_t root_cert_index;
    uint16_t data16;
#if !(LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT) &amp;&amp; LIBSPDM_CERT_PARSE_SUPPORT
    bool status;
    const uint8_t *cert_buffer;
    size_t cert_buffer_size;
#endif

<span style = "background-color:#dfd">    if (spdm_context == NULL || data == NULL || data_type &gt;= LIBSPDM_DATA_MAX) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
    }

<span style = "background-color:#dfd">    context = spdm_context;</span>

<span style = "background-color:#dfd">    if (need_session_info_for_data(data_type)) {</span>
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_SESSION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        session_id = libspdm_read_uint32(parameter-&gt;additional_data);
        session_info = libspdm_get_session_info_via_session_id(context, session_id);
        if (session_info == NULL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">    } else {</span>
<span style = "background-color:#dfd">        session_info = NULL;</span>
    }

<span style = "background-color:#dfd">    switch (data_type) {</span>
    case LIBSPDM_DATA_SPDM_VERSION:
<span style = "background-color:#dfd">        LIBSPDM_ASSERT (data_size &lt;= sizeof(spdm_version_number_t) * SPDM_MAX_VERSION_COUNT);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
            /* Only have one connected version */
<span style = "background-color:#fdd">            LIBSPDM_ASSERT (data_size == sizeof(spdm_version_number_t));
            libspdm_copy_mem(&amp;(context-&gt;connection_info.version),</span>
                             sizeof(context-&gt;connection_info.version),
                             data,
                             sizeof(spdm_version_number_t));
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.version.spdm_version_count =</span>
                (uint8_t)(data_size / sizeof(spdm_version_number_t));
<span style = "background-color:#dfd">            libspdm_copy_mem(context-&gt;local_context.version.spdm_version,</span>
                             sizeof(context-&gt;local_context.version.spdm_version),
                             data,
                             context-&gt;local_context.version.spdm_version_count *
                             sizeof(spdm_version_number_t));
<span style = "background-color:#dfd">        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_SECURED_MESSAGE_VERSION:
<span style = "background-color:#fdd">        LIBSPDM_ASSERT (data_size &lt;=</span>
                        sizeof(spdm_version_number_t) * SECURED_SPDM_MAX_VERSION_COUNT);
<span style = "background-color:#fdd">        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
            /* Only have one connected version */
<span style = "background-color:#fdd">            LIBSPDM_ASSERT (data_size == sizeof(spdm_version_number_t));
            libspdm_copy_mem(&amp;(context-&gt;connection_info.secured_message_version),</span>
                             sizeof(context-&gt;connection_info.secured_message_version),
                             data,
                             sizeof(spdm_version_number_t));
<span style = "background-color:#fdd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {</span>
            context-&gt;local_context.secured_message_version
<span style = "background-color:#fdd">            .spdm_version_count = (uint8_t)(data_size / sizeof(spdm_version_number_t));
            libspdm_copy_mem(context-&gt;local_context</span>
                             .secured_message_version.spdm_version,
                             sizeof(context-&gt;local_context
                                    .secured_message_version.spdm_version),
                             data,
                             context-&gt;local_context.secured_message_version.
                             spdm_version_count * sizeof(spdm_version_number_t));
<span style = "background-color:#fdd">        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_CAPABILITY_FLAGS:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint32_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }

<span style = "background-color:#dfd">        data32 = libspdm_read_uint32((const uint8_t *)data);</span>

<span style = "background-color:#dfd">        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {</span>
            #if !(LIBSPDM_ENABLE_CAPABILITY_CERT_CAP)
            LIBSPDM_ASSERT((data32 &amp; SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CERT_CAP) == 0);
            #endif /* !LIBSPDM_ENABLE_CAPABILITY_CERT_CAP */

            #if !(LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP)
            LIBSPDM_ASSERT((data32 &amp; SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHAL_CAP) == 0);
            #endif /* !LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP */

            #if !(LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP)
            LIBSPDM_ASSERT((data32 &amp; SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP) == 0);
            #endif /* !LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP */

            #if !(LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP)
<span style = "background-color:#dfd">            LIBSPDM_ASSERT((data32 &amp; SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP) == 0);</span>
            #endif /* !LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP */

            #if !(LIBSPDM_ENABLE_CAPABILITY_PSK_CAP)
<span style = "background-color:#dfd">            LIBSPDM_ASSERT((data32 &amp; SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP) == 0);</span>
            #endif /* !LIBSPDM_ENABLE_CAPABILITY_PSK_CAP */

<span style = "background-color:#dfd">            context-&gt;local_context.capability.flags = data32;</span>
<span style = "background-color:#fdd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {
            context-&gt;connection_info.capability.flags = data32;
        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_CAPABILITY_CT_EXPONENT:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint8_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.capability.ct_exponent = *(uint8_t *)data;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.capability.ct_exponent = *(uint8_t *)data;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_CAPABILITY_RTT_US:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint64_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.capability.rtt = libspdm_read_uint64((const uint8_t *)data);
        break;</span>
    case LIBSPDM_DATA_CAPABILITY_MAX_SPDM_MSG_SIZE:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint32_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
        /* The local max_spdm_msg_size is set by libspdm_register_transport_layer_func.
         * Only the connection's max_spdm_msg_size is settable here. */
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        data32 = libspdm_read_uint32((const uint8_t *)data);
        LIBSPDM_ASSERT (data32 &gt;= SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12);
        context-&gt;connection_info.capability.max_spdm_msg_size = data32;
        break;</span>
    case LIBSPDM_DATA_MEASUREMENT_SPEC:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint8_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.measurement_spec = *(uint8_t *)data;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.measurement_spec = *(uint8_t *)data;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_MEASUREMENT_HASH_ALGO:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint32_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        data32 = libspdm_read_uint32((const uint8_t *)data);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.measurement_hash_algo = data32;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.measurement_hash_algo = data32;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_BASE_ASYM_ALGO:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint32_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        data32 = libspdm_read_uint32((const uint8_t *)data);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.base_asym_algo = data32;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.base_asym_algo = data32;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_BASE_HASH_ALGO:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint32_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        data32 = libspdm_read_uint32((const uint8_t *)data);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.base_hash_algo = data32;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.base_hash_algo = data32;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_DHE_NAME_GROUP:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint16_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        data16 = libspdm_read_uint16((const uint8_t *)data);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.dhe_named_group = data16;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.dhe_named_group = data16;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_AEAD_CIPHER_SUITE:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint16_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        data16 = libspdm_read_uint16((const uint8_t *)data);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.aead_cipher_suite = data16;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.aead_cipher_suite = data16;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_REQ_BASE_ASYM_ALG:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint16_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        data16 = libspdm_read_uint16((const uint8_t *)data);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {
            context-&gt;connection_info.algorithm.req_base_asym_alg = data16;
        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.req_base_asym_alg = data16;
        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_KEY_SCHEDULE:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint16_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        data16 = libspdm_read_uint16((const uint8_t *)data);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.key_schedule = data16;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.key_schedule = data16;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_OTHER_PARAMS_SUPPORT:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint8_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.other_params_support = *(uint8_t *)data;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.other_params_support = *(uint8_t *)data;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_MEL_SPEC:
<span style = "background-color:#dfd">        if (data_size != sizeof(uint8_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            context-&gt;connection_info.algorithm.mel_spec = *(uint8_t *)data;</span>
<span style = "background-color:#dfd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            context-&gt;local_context.algorithm.mel_spec = *(uint8_t *)data;
        } else {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_CONNECTION_STATE:
<span style = "background-color:#fdd">        if (data_size != sizeof(libspdm_connection_state_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;connection_info.connection_state = libspdm_read_uint32((const uint8_t *)data);
        break;</span>
    case LIBSPDM_DATA_RESPONSE_STATE:
<span style = "background-color:#fdd">        if (data_size != sizeof(libspdm_response_state_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;response_state = libspdm_read_uint32((const uint8_t *)data);
        break;</span>
    case LIBSPDM_DATA_PEER_PUBLIC_ROOT_CERT:
<span style = "background-color:#dfd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        root_cert_index = 0;
        while (context-&gt;local_context.peer_root_cert_provision[root_cert_index] != NULL) {
            root_cert_index++;
            if (root_cert_index &gt;= LIBSPDM_MAX_ROOT_CERT_SUPPORT) {</span>
<span style = "background-color:#fdd">                return LIBSPDM_STATUS_BUFFER_FULL;</span>
            }
<span style = "background-color:#dfd">        }
        context-&gt;local_context.peer_root_cert_provision_size[root_cert_index] = data_size;
        context-&gt;local_context.peer_root_cert_provision[root_cert_index] = data;
        break;</span>
    case LIBSPDM_DATA_LOCAL_PUBLIC_CERT_CHAIN:
<span style = "background-color:#dfd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        context-&gt;local_context.local_cert_chain_provision_size[slot_id] = data_size;
        context-&gt;local_context.local_cert_chain_provision[slot_id] = data;
        break;</span>
    case LIBSPDM_DATA_LOCAL_SUPPORTED_SLOT_MASK:
<span style = "background-color:#dfd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        slot_id = parameter-&gt;additional_data[0];
        if (data_size != sizeof(uint8_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        context-&gt;local_context.local_supported_slot_mask = *(uint8_t *)data;
        break;</span>
    case LIBSPDM_DATA_LOCAL_KEY_PAIR_ID:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (data_size != sizeof(spdm_key_pair_id_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.local_key_pair_id[slot_id] = *(spdm_key_pair_id_t *)data;
        break;</span>
    case LIBSPDM_DATA_LOCAL_CERT_INFO:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (data_size != sizeof(spdm_certificate_info_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.local_cert_info[slot_id] = *(spdm_certificate_info_t *)data;
        break;</span>
    case LIBSPDM_DATA_LOCAL_KEY_USAGE_BIT_MASK:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (data_size != sizeof(spdm_key_usage_bit_mask_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.local_key_usage_bit_mask[slot_id] =</span>
            libspdm_read_uint16((const uint8_t *)data);
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_PEER_USED_CERT_CHAIN_BUFFER:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (data_size &gt; LIBSPDM_MAX_CERT_CHAIN_SIZE) {
            return LIBSPDM_STATUS_BUFFER_FULL;</span>
        }
<span style = "background-color:#fdd">        context-&gt;connection_info.peer_used_cert_chain_slot_id = slot_id;</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
        context-&gt;connection_info.peer_used_cert_chain[slot_id].buffer_size = data_size;
        libspdm_copy_mem(context-&gt;connection_info.peer_used_cert_chain[slot_id].buffer,
                         sizeof(context-&gt;connection_info.peer_used_cert_chain[slot_id].buffer),
                         data, data_size);
#else
#if LIBSPDM_CERT_PARSE_SUPPORT
<span style = "background-color:#fdd">        status = libspdm_hash_all(</span>
            context-&gt;connection_info.algorithm.base_hash_algo,
            data, data_size,
            context-&gt;connection_info.peer_used_cert_chain[slot_id].buffer_hash);
<span style = "background-color:#fdd">        if (!status) {
            return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
        }

<span style = "background-color:#fdd">        context-&gt;connection_info.peer_used_cert_chain[slot_id].buffer_hash_size =</span>
            libspdm_get_hash_size(context-&gt;connection_info.algorithm.base_hash_algo);

        /*process the SPDM cert header and hash*/
<span style = "background-color:#fdd">        data = (uint8_t *)data + sizeof(spdm_cert_chain_t) +</span>
               libspdm_get_hash_size(context-&gt;connection_info.algorithm.base_hash_algo);
<span style = "background-color:#fdd">        data_size = data_size -</span>
                    (sizeof(spdm_cert_chain_t) +
                     libspdm_get_hash_size(context-&gt;connection_info.algorithm.base_hash_algo));

        /* Get leaf cert from cert chain */
<span style = "background-color:#fdd">        status = libspdm_x509_get_cert_from_cert_chain(data, data_size, -1,</span>
                                                       &amp;cert_buffer, &amp;cert_buffer_size);
<span style = "background-color:#fdd">        if (!status) {
            return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
        }

<span style = "background-color:#fdd">        status = false;</span>
#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
<span style = "background-color:#fdd">        if (!status) {
            status = libspdm_rsa_get_public_key_from_x509(</span>
                cert_buffer, cert_buffer_size,
                &amp;context-&gt;connection_info.peer_used_cert_chain[slot_id].leaf_cert_public_key);
        }
#endif
#if LIBSPDM_ECDSA_SUPPORT
<span style = "background-color:#fdd">        if (!status) {
            status = libspdm_ec_get_public_key_from_x509(</span>
                cert_buffer, cert_buffer_size,
                &amp;context-&gt;connection_info.peer_used_cert_chain[slot_id].leaf_cert_public_key);
        }
#endif
#if (LIBSPDM_EDDSA_ED25519_SUPPORT) || (LIBSPDM_EDDSA_ED448_SUPPORT)
        if (!status) {
            status = libspdm_ecd_get_public_key_from_x509(
                cert_buffer, cert_buffer_size,
                &amp;context-&gt;connection_info.peer_used_cert_chain[slot_id].leaf_cert_public_key);
        }
#endif
#if LIBSPDM_SM2_DSA_SUPPORT
        if (!status) {
            status = libspdm_sm2_get_public_key_from_x509(
                cert_buffer, cert_buffer_size,
                &amp;context-&gt;connection_info.peer_used_cert_chain[slot_id].leaf_cert_public_key);
        }
#endif
<span style = "background-color:#fdd">        if (!status) {
            return LIBSPDM_STATUS_INVALID_CERT;</span>
        }
#else
        LIBSPDM_ASSERT (false);
#endif /* LIBSPDM_CERT_PARSE_SUPPORT */
#endif /* LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT */
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_PEER_PUBLIC_KEY:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.peer_public_key_provision_size = data_size;
        context-&gt;local_context.peer_public_key_provision = data;
        break;</span>
    case LIBSPDM_DATA_LOCAL_PUBLIC_KEY:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.local_public_key_provision_size = data_size;
        context-&gt;local_context.local_public_key_provision = data;
        break;</span>
    case LIBSPDM_DATA_BASIC_MUT_AUTH_REQUESTED:
<span style = "background-color:#fdd">        if (data_size != sizeof(bool)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        mut_auth_requested = *(uint8_t *)data;
        if (((mut_auth_requested != 0) &amp;&amp; (mut_auth_requested != 1))) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.basic_mut_auth_requested = mut_auth_requested;
        context-&gt;encap_context.request_id = 0;
        slot_id = parameter-&gt;additional_data[0];
        if ((slot_id &gt;= SPDM_MAX_SLOT_COUNT) &amp;&amp; (slot_id != 0xFF)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;encap_context.req_slot_id = slot_id;</span>

        #if LIBSPDM_DEBUG_PRINT_ENABLE
<span style = "background-color:#fdd">        if (mut_auth_requested) {
            LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                           "Basic mutual authentication is a deprecated feature.\n"));</span>
        }
        #endif /* LIBSPDM_DEBUG_PRINT_ENABLE */
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_MUT_AUTH_REQUESTED:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint8_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        mut_auth_requested = *(uint8_t *)data;</span>
        if (((mut_auth_requested != 0) &amp;&amp;
             (mut_auth_requested !=
              SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED) &amp;&amp;
             (mut_auth_requested !=
<span style = "background-color:#fdd">              SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED_WITH_ENCAP_REQUEST) &amp;&amp;</span>
             (mut_auth_requested !=
              SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED_WITH_GET_DIGESTS))) {
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.mut_auth_requested = mut_auth_requested;
        context-&gt;encap_context.request_id = 0;
        slot_id = parameter-&gt;additional_data[0];
        if ((slot_id &gt;= SPDM_MAX_SLOT_COUNT) &amp;&amp; (slot_id != 0xFF)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;encap_context.req_slot_id = slot_id;
        break;</span>
    case LIBSPDM_DATA_HEARTBEAT_PERIOD:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint8_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;local_context.heartbeat_period = *(uint8_t *)data;
        break;</span>
    case LIBSPDM_DATA_APP_CONTEXT_DATA:
<span style = "background-color:#fdd">        if (data_size != sizeof(void *) || *(void **)data == NULL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;app_context_data_ptr = *(void **)data;
        break;</span>
    case LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint8_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;handle_error_return_policy = *(uint8_t *)data;
        break;</span>
    case LIBSPDM_DATA_VCA_CACHE:
<span style = "background-color:#fdd">        if (data_size &gt; sizeof(context-&gt;transcript.message_a.buffer)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;transcript.message_a.buffer_size = data_size;
        libspdm_copy_mem(context-&gt;transcript.message_a.buffer,</span>
                         sizeof(context-&gt;transcript.message_a.buffer),
                         data, data_size);
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_IS_REQUESTER:
<span style = "background-color:#dfd">        if (data_size != sizeof(bool)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_LOCAL) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        context-&gt;local_context.is_requester = *(bool *)data;
        break;</span>
    case LIBSPDM_DATA_REQUEST_RETRY_TIMES:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint8_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;retry_times = *(uint8_t *)data;
        break;</span>
    case LIBSPDM_DATA_REQUEST_RETRY_DELAY_TIME:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint64_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;retry_delay_time = *(uint64_t *)data;
        break;</span>
    case LIBSPDM_DATA_MAX_DHE_SESSION_COUNT:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint32_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (*(uint32_t *)data &gt; LIBSPDM_MAX_SESSION_COUNT - context-&gt;max_psk_session_count) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;max_dhe_session_count = *(uint32_t *)data;
        break;</span>
    case LIBSPDM_DATA_MAX_PSK_SESSION_COUNT:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint32_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (*(uint32_t *)data &gt; LIBSPDM_MAX_SESSION_COUNT - context-&gt;max_dhe_session_count) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;max_psk_session_count = *(uint32_t *)data;
        break;</span>
    case LIBSPDM_DATA_MAX_SPDM_SESSION_SEQUENCE_NUMBER:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint64_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;max_spdm_session_sequence_number = *(uint64_t *)data;
        if (context-&gt;max_spdm_session_sequence_number == 0) {
            context-&gt;max_spdm_session_sequence_number = LIBSPDM_MAX_SPDM_SESSION_SEQUENCE_NUMBER;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_SPDM_VERSION_10_11_VERIFY_SIGNATURE_ENDIAN:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint8_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
        if (*(uint8_t*)data != LIBSPDM_SPDM_10_11_VERIFY_SIGNATURE_ENDIAN_BIG_ONLY &amp;&amp;
<span style = "background-color:#fdd">            *(uint8_t*)data != LIBSPDM_SPDM_10_11_VERIFY_SIGNATURE_ENDIAN_LITTLE_ONLY &amp;&amp;</span>
            *(uint8_t*)data != LIBSPDM_SPDM_10_11_VERIFY_SIGNATURE_ENDIAN_BIG_OR_LITTLE) {
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;spdm_10_11_verify_signature_endian = *(uint8_t*)data;
        break;</span>
    case LIBSPDM_DATA_SEQUENCE_NUMBER_ENDIAN:
<span style = "background-color:#fdd">        if (data_size != sizeof(uint8_t)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;sequence_number_endian = *(uint8_t *)data;
        break;</span>
    case LIBSPDM_DATA_MULTI_KEY_CONN_REQ:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (data_size != sizeof(bool)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;connection_info.multi_key_conn_req = *(bool *)data;
        break;</span>
    case LIBSPDM_DATA_MULTI_KEY_CONN_RSP:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        if (data_size != sizeof(bool)) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        context-&gt;connection_info.multi_key_conn_rsp = *(bool *)data;
        break;</span>
    default:
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
        break;
    }

<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

/**
 * Get an SPDM context data.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  data_type                     Type of the SPDM context data.
 * @param  parameter                    Type specific parameter of the SPDM context data.
 * @param  data                         A pointer to the SPDM context data.
 * @param  data_size                     size in bytes of the SPDM context data.
 *                                     On input, it means the size in bytes of data buffer.
 *                                     On output, it means the size in bytes of copied data buffer if RETURN_SUCCESS,
 *                                     and means the size in bytes of desired data buffer if RETURN_BUFFER_TOO_SMALL.
 *
 * @retval RETURN_SUCCESS               The SPDM context data is set successfully.
 * @retval RETURN_INVALID_PARAMETER     The data_size is NULL or the data is NULL and *data_size is not zero.
 * @retval RETURN_UNSUPPORTED           The data_type is unsupported.
 * @retval RETURN_NOT_FOUND             The data_type cannot be found.
 * @retval RETURN_NOT_READY             The data is not ready to return.
 * @retval RETURN_BUFFER_TOO_SMALL      The buffer is too small to hold the data.
 **/
libspdm_return_t libspdm_get_data(void *spdm_context, libspdm_data_type_t data_type,
                                  const libspdm_data_parameter_t *parameter,
                                  void *data, size_t *data_size)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    libspdm_secured_message_context_t *secured_context;
    size_t target_data_size;
    void *target_data;
    uint32_t session_id;
    libspdm_session_info_t *session_info;
    size_t digest_size;
    size_t digest_count;
    uint8_t slot_id;
    size_t index;

<span style = "background-color:#dfd">    if (spdm_context == NULL || data == NULL || data_size == NULL ||</span>
        data_type &gt;= LIBSPDM_DATA_MAX) {
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
    }

<span style = "background-color:#dfd">    context = spdm_context;</span>

<span style = "background-color:#dfd">    if (data_type == LIBSPDM_DATA_SESSION_END_SESSION_ATTRIBUTES) {</span>
        /* end_session_attributes is present in both a session context as well as an
         * spdm context. */
<span style = "background-color:#fdd">        session_id = libspdm_read_uint32(parameter-&gt;additional_data);
        session_info = libspdm_get_session_info_via_session_id(context, session_id);</span>
<span style = "background-color:#dfd">    } else if (need_session_info_for_data(data_type)) {</span>
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_SESSION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        session_id = libspdm_read_uint32(parameter-&gt;additional_data);
        session_info = libspdm_get_session_info_via_session_id(context, session_id);
        if (session_info == NULL) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        secured_context = session_info-&gt;secured_message_context;
    } else {</span>
<span style = "background-color:#dfd">        session_info = NULL;</span>
    }

<span style = "background-color:#dfd">    switch (data_type) {</span>
    case LIBSPDM_DATA_SPDM_VERSION:
<span style = "background-color:#dfd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        target_data_size = sizeof(spdm_version_number_t);
        target_data = &amp;(context-&gt;connection_info.version);
        break;</span>
    case LIBSPDM_DATA_SECURED_MESSAGE_VERSION:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(spdm_version_number_t);
        target_data = &amp;(context-&gt;connection_info.secured_message_version);
        break;</span>
    case LIBSPDM_DATA_CAPABILITY_FLAGS:
<span style = "background-color:#dfd">        target_data_size = sizeof(uint32_t);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {
            target_data = &amp;context-&gt;connection_info.capability.flags;</span>
<span style = "background-color:#fdd">        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            target_data = &amp;context-&gt;local_context.capability.flags;
        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case LIBSPDM_DATA_CAPABILITY_CT_EXPONENT:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {
            target_data = &amp;context-&gt;connection_info.capability.ct_exponent;
        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            target_data = &amp;context-&gt;local_context.capability.ct_exponent;
        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_CAPABILITY_DATA_TRANSFER_SIZE:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint32_t);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {
            target_data = &amp;context-&gt;connection_info.capability.data_transfer_size;
        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            target_data = &amp;context-&gt;local_context.capability.data_transfer_size;
        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_CAPABILITY_MAX_SPDM_MSG_SIZE:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint32_t);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {
            target_data = &amp;context-&gt;connection_info.capability.max_spdm_msg_size;
        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            target_data = &amp;context-&gt;local_context.capability.max_spdm_msg_size;
        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_CAPABILITY_SENDER_DATA_TRANSFER_SIZE:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint32_t);
        if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;
        } else if (parameter-&gt;location == LIBSPDM_DATA_LOCATION_LOCAL) {
            target_data = &amp;context-&gt;local_context.capability.sender_data_transfer_size;
        } else {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_MEASUREMENT_SPEC:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;connection_info.algorithm.measurement_spec;
        break;</span>
    case LIBSPDM_DATA_MEASUREMENT_HASH_ALGO:
<span style = "background-color:#dfd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        target_data_size = sizeof(uint32_t);
        target_data = &amp;context-&gt;connection_info.algorithm.measurement_hash_algo;
        break;</span>
    case LIBSPDM_DATA_BASE_ASYM_ALGO:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint32_t);
        target_data = &amp;context-&gt;connection_info.algorithm.base_asym_algo;
        break;</span>
    case LIBSPDM_DATA_BASE_HASH_ALGO:
<span style = "background-color:#dfd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#dfd">        target_data_size = sizeof(uint32_t);
        target_data = &amp;context-&gt;connection_info.algorithm.base_hash_algo;
        break;</span>
    case LIBSPDM_DATA_DHE_NAME_GROUP:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint16_t);
        target_data = &amp;context-&gt;connection_info.algorithm.dhe_named_group;
        break;</span>
    case LIBSPDM_DATA_AEAD_CIPHER_SUITE:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint16_t);
        target_data = &amp;context-&gt;connection_info.algorithm.aead_cipher_suite;
        break;</span>
    case LIBSPDM_DATA_REQ_BASE_ASYM_ALG:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint16_t);
        target_data = &amp;context-&gt;connection_info.algorithm.req_base_asym_alg;
        break;</span>
    case LIBSPDM_DATA_KEY_SCHEDULE:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint16_t);
        target_data = &amp;context-&gt;connection_info.algorithm.key_schedule;
        break;</span>
    case LIBSPDM_DATA_OTHER_PARAMS_SUPPORT:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;connection_info.algorithm.other_params_support;
        break;</span>
    case LIBSPDM_DATA_MEL_SPEC:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;connection_info.algorithm.mel_spec;
        break;</span>
    case LIBSPDM_DATA_CONNECTION_STATE:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(libspdm_connection_state_t);
        target_data = &amp;context-&gt;connection_info.connection_state;
        break;</span>
    case LIBSPDM_DATA_RESPONSE_STATE:
<span style = "background-color:#fdd">        target_data_size = sizeof(libspdm_response_state_t);
        target_data = &amp;context-&gt;response_state;
        break;</span>
    case LIBSPDM_DATA_PEER_PROVISIONED_SLOT_MASK:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;connection_info.peer_provisioned_slot_mask;
        break;</span>
    case LIBSPDM_DATA_PEER_SUPPORTED_SLOT_MASK:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;connection_info.peer_supported_slot_mask;
        break;</span>
    case LIBSPDM_DATA_PEER_TOTAL_DIGEST_BUFFER:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        digest_count = 0;
        for (index = 0; index &lt; SPDM_MAX_SLOT_COUNT; index++) {
            if (context-&gt;connection_info.peer_provisioned_slot_mask &amp; (1 &lt;&lt; index)) {
                digest_count++;</span>
            }
<span style = "background-color:#fdd">        }
        digest_size = libspdm_get_hash_size(context-&gt;connection_info.algorithm.base_hash_algo);
        target_data_size = digest_size * digest_count;
        target_data = context-&gt;connection_info.peer_total_digest_buffer;
        break;</span>
    case LIBSPDM_DATA_PEER_KEY_PAIR_ID:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(spdm_key_pair_id_t);
        target_data = &amp;context-&gt;connection_info.peer_key_pair_id[slot_id];
        break;</span>
    case LIBSPDM_DATA_PEER_CERT_INFO:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(spdm_certificate_info_t);
        target_data = &amp;context-&gt;connection_info.peer_cert_info[slot_id];
        break;</span>
    case LIBSPDM_DATA_PEER_KEY_USAGE_BIT_MASK:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        slot_id = parameter-&gt;additional_data[0];
        if (slot_id &gt;= SPDM_MAX_SLOT_COUNT) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(spdm_key_usage_bit_mask_t);
        target_data = &amp;context-&gt;connection_info.peer_key_usage_bit_mask[slot_id];
        break;</span>
    case LIBSPDM_DATA_SESSION_USE_PSK:
<span style = "background-color:#fdd">        target_data_size = sizeof(bool);
        target_data = &amp;session_info-&gt;use_psk;
        break;</span>
    case LIBSPDM_DATA_SESSION_MUT_AUTH_REQUESTED:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;session_info-&gt;mut_auth_requested;
        break;</span>
    case LIBSPDM_DATA_SESSION_END_SESSION_ATTRIBUTES:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        if (session_info == NULL) {
            target_data = &amp;context-&gt;connection_info.end_session_attributes;
        } else {
            target_data = &amp;session_info-&gt;end_session_attributes;</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_DATA_SESSION_POLICY:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;session_info-&gt;session_policy;
        break;</span>
    case LIBSPDM_DATA_APP_CONTEXT_DATA:
<span style = "background-color:#fdd">        target_data_size = sizeof(void *);
        target_data = &amp;context-&gt;app_context_data_ptr;
        break;</span>
    case LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;handle_error_return_policy;
        break;</span>
    case LIBSPDM_DATA_MAX_DHE_SESSION_COUNT:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint32_t);
        target_data = &amp;context-&gt;max_dhe_session_count;
        break;</span>
    case LIBSPDM_DATA_MAX_PSK_SESSION_COUNT:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint32_t);
        target_data = &amp;context-&gt;max_psk_session_count;
        break;</span>
    case LIBSPDM_DATA_SESSION_SEQUENCE_NUMBER_REQ_DIR:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint64_t);
        target_data = &amp;secured_context-&gt;application_secret.request_data_sequence_number;
        break;</span>
    case LIBSPDM_DATA_SESSION_SEQUENCE_NUMBER_RSP_DIR:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint64_t);
        target_data = &amp;secured_context-&gt;application_secret.response_data_sequence_number;
        break;</span>
    case LIBSPDM_DATA_MAX_SPDM_SESSION_SEQUENCE_NUMBER:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint64_t);
        target_data = &amp;context-&gt;max_spdm_session_sequence_number;
        break;</span>
    case LIBSPDM_DATA_VCA_CACHE:
<span style = "background-color:#fdd">        target_data_size = context-&gt;transcript.message_a.buffer_size;
        target_data = context-&gt;transcript.message_a.buffer;
        break;</span>
    case LIBSPDM_DATA_SPDM_VERSION_10_11_VERIFY_SIGNATURE_ENDIAN:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;spdm_10_11_verify_signature_endian;
        break;</span>
    case LIBSPDM_DATA_SEQUENCE_NUMBER_ENDIAN:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;context-&gt;sequence_number_endian;
        break;</span>
    case LIBSPDM_DATA_SESSION_SEQUENCE_NUMBER_ENDIAN:
<span style = "background-color:#fdd">        target_data_size = sizeof(uint8_t);
        target_data = &amp;secured_context-&gt;sequence_number_endian;
        break;</span>
    case LIBSPDM_DATA_MULTI_KEY_CONN_REQ:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(bool);
        target_data = &amp;context-&gt;connection_info.multi_key_conn_req;
        break;</span>
    case LIBSPDM_DATA_MULTI_KEY_CONN_RSP:
<span style = "background-color:#fdd">        if (parameter-&gt;location != LIBSPDM_DATA_LOCATION_CONNECTION) {
            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }
<span style = "background-color:#fdd">        target_data_size = sizeof(bool);
        target_data = &amp;context-&gt;connection_info.multi_key_conn_rsp;
        break;</span>
    default:
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
        break;
    }

<span style = "background-color:#dfd">    if (*data_size &lt; target_data_size) {</span>
<span style = "background-color:#fdd">        *data_size = target_data_size;
        return LIBSPDM_STATUS_BUFFER_TOO_SMALL;</span>
    }
<span style = "background-color:#dfd">    libspdm_copy_mem(data, *data_size, target_data, target_data_size);
    *data_size = target_data_size;</span>

<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

#if LIBSPDM_CHECK_SPDM_CONTEXT
bool libspdm_check_context (void *spdm_context)
{
    libspdm_context_t *context;
    size_t index;

    context = spdm_context;

    if (context-&gt;local_context.capability.data_transfer_size &lt;
        SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR,
                       "data_transfer_size must be greater than or equal "
                       "to SPDM_MIN_DATA_TRANSFER_SIZE (%d).\n",
                       SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12));
        return false;
    }

    if (context-&gt;local_context.capability.max_spdm_msg_size &lt;
        context-&gt;local_context.capability.data_transfer_size) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR,
                       "max_spdm_msg_size (%d) must be greater than or "
                       "equal to data_transfer_size (%d).\n",
                       context-&gt;local_context.capability.max_spdm_msg_size,
                       context-&gt;local_context.capability.data_transfer_size));
        return false;
    }

    if (context-&gt;local_context.capability.sender_data_transfer_size &lt;
        SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR,
                       "sender_data_transfer_size must be greater than or equal "
                       "to %d.\n", SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12));
        return false;
    }

    if (context-&gt;local_context.capability.max_spdm_msg_size &lt;
        context-&gt;local_context.capability.sender_data_transfer_size) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR,
                       "max_spdm_msg_size (%d) must be greater than or "
                       "equal to sender_data_transfer_size (%d).\n",
                       context-&gt;local_context.capability.max_spdm_msg_size,
                       context-&gt;local_context.capability.sender_data_transfer_size));
        return false;
    }

    if (((context-&gt;local_context.capability.flags &amp;
          SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHUNK_CAP) != 0) &amp;&amp;
        (context-&gt;local_context.capability.max_spdm_msg_size != 0)) {
        for (index = 0; index &lt; SPDM_MAX_SLOT_COUNT; index++) {
            if ((context-&gt;local_context.local_cert_chain_provision_size[index] != 0) &amp;&amp;
                (context-&gt;local_context.local_cert_chain_provision_size[index] +
                 sizeof(spdm_certificate_response_t) &gt;
                 context-&gt;local_context.capability.max_spdm_msg_size)) {
                LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR,
                               "max_spdm_msg_size (%d) must be greater than or "
                               "equal to local_cert_chain_provision_size[%d] (%d).\n",
                               context-&gt;local_context.capability.max_spdm_msg_size, index,
                               context-&gt;local_context.local_cert_chain_provision_size[index]));
                return false;
            }
        }
    }

    return true;
}
#endif /* LIBSPDM_CHECK_CONTEXT */

/**
 * Reset message A cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 **/
void libspdm_reset_message_a(libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{
    libspdm_reset_managed_buffer(&amp;spdm_context-&gt;transcript.message_a);
}</span>

/**
 * Reset message D cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 **/
void libspdm_reset_message_d(libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{
    libspdm_reset_managed_buffer(&amp;spdm_context-&gt;transcript.message_d);
}</span>

/**
 * Reset message B cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 **/
void libspdm_reset_message_b(libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    libspdm_reset_managed_buffer(&amp;spdm_context-&gt;transcript.message_b);
#else
<span style = "background-color:#dfd">    if (spdm_context-&gt;transcript.digest_context_m1m2 != NULL) {
        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                           spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#dfd">        spdm_context-&gt;transcript.digest_context_m1m2 = NULL;</span>
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Reset message C cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 **/
void libspdm_reset_message_c(libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    libspdm_reset_managed_buffer(&amp;spdm_context-&gt;transcript.message_c);
#else
<span style = "background-color:#dfd">    if (spdm_context-&gt;transcript.digest_context_m1m2 != NULL) {
        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                           spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#dfd">        spdm_context-&gt;transcript.digest_context_m1m2 = NULL;</span>
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Reset message MutB cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 **/
void libspdm_reset_message_mut_b(libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    libspdm_reset_managed_buffer(&amp;spdm_context-&gt;transcript.message_mut_b);
#else
<span style = "background-color:#dfd">    if (spdm_context-&gt;transcript.digest_context_mut_m1m2 != NULL) {</span>
<span style = "background-color:#fdd">        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                           spdm_context-&gt;transcript.digest_context_mut_m1m2);
<span style = "background-color:#fdd">        spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;</span>
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Reset message MutC cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 **/
void libspdm_reset_message_mut_c(libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    libspdm_reset_managed_buffer(&amp;spdm_context-&gt;transcript.message_mut_c);
#else
<span style = "background-color:#dfd">    if (spdm_context-&gt;transcript.digest_context_mut_m1m2 != NULL) {</span>
<span style = "background-color:#fdd">        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                           spdm_context-&gt;transcript.digest_context_mut_m1m2);
<span style = "background-color:#fdd">        spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;</span>
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Reset message M cache in SPDM context.
 * If session_info is NULL, this function will use M cache of SPDM context,
 * else will use M cache of SPDM session context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  session_info                  A pointer to the SPDM session context.
 **/
void libspdm_reset_message_m(libspdm_context_t *spdm_context, void *session_info)
<span style = "background-color:#dfd">{</span>
    libspdm_session_info_t *spdm_session_info;

<span style = "background-color:#dfd">    spdm_session_info = session_info;</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    if (spdm_session_info == NULL) {
        libspdm_reset_managed_buffer(&amp;spdm_context-&gt;transcript.message_m);
    } else {
        libspdm_reset_managed_buffer(&amp;spdm_session_info-&gt;session_transcript.message_m);
    }
#else
<span style = "background-color:#dfd">    if (spdm_session_info == NULL) {
        if (spdm_context-&gt;transcript.digest_context_l1l2 != NULL) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                               spdm_context-&gt;transcript.digest_context_l1l2);
<span style = "background-color:#dfd">            spdm_context-&gt;transcript.digest_context_l1l2 = NULL;</span>
        }
<span style = "background-color:#dfd">    } else {</span>
<span style = "background-color:#fdd">        if (spdm_session_info-&gt;session_transcript.digest_context_l1l2 != NULL) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                               spdm_session_info-&gt;session_transcript.digest_context_l1l2);
<span style = "background-color:#fdd">            spdm_session_info-&gt;session_transcript.digest_context_l1l2 = NULL;</span>
        }
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Reset message K cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  spdm_session_info              A pointer to the SPDM session context.
 **/
void libspdm_reset_message_k(libspdm_context_t *spdm_context, void *session_info)
{
    libspdm_session_info_t *spdm_session_info;

    spdm_session_info = session_info;
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    libspdm_reset_managed_buffer(&amp;spdm_session_info-&gt;session_transcript.message_k);
#else
    {
        if (spdm_session_info-&gt;session_transcript.digest_context_th != NULL) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                               spdm_session_info-&gt;session_transcript.digest_context_th);
            spdm_session_info-&gt;session_transcript.digest_context_th = NULL;
        }
        if (spdm_session_info-&gt;session_transcript.digest_context_th_backup != NULL) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                               spdm_session_info-&gt;session_transcript.digest_context_th_backup);
            spdm_session_info-&gt;session_transcript.digest_context_th_backup = NULL;
        }
    }
#endif
}

/**
 * Reset message EncapD cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  spdm_session_info              A pointer to the SPDM session context.
 **/
void libspdm_reset_message_encap_d(libspdm_context_t *spdm_context, void *session_info)
{
    libspdm_session_info_t *spdm_session_info;

    spdm_session_info = session_info;
    libspdm_reset_managed_buffer(&amp;spdm_session_info-&gt;session_transcript.message_encap_d);
}

/**
 * Reset message F cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  spdm_session_info              A pointer to the SPDM session context.
 **/
void libspdm_reset_message_f(libspdm_context_t *spdm_context, void *session_info)
{
    libspdm_session_info_t *spdm_session_info;

    spdm_session_info = session_info;
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    libspdm_reset_managed_buffer(&amp;spdm_session_info-&gt;session_transcript.message_f);
#else
    {
        if (spdm_session_info-&gt;session_transcript.digest_context_th != NULL) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                               spdm_session_info-&gt;session_transcript.digest_context_th);
            spdm_session_info-&gt;session_transcript.digest_context_th =
                spdm_session_info-&gt;session_transcript.digest_context_th_backup;
            spdm_session_info-&gt;session_transcript.digest_context_th_backup = NULL;
        }
        spdm_session_info-&gt;session_transcript.message_f_initialized = false;
    }
#endif
}

/**
 * Reset message buffer in SPDM context according to request code.
 *
 * @param  spdm_context                   A pointer to the SPDM context.
 * @param  spdm_session_info             A pointer to the SPDM session context.
 * @param  spdm_request                   The SPDM request code.
 */
void libspdm_reset_message_buffer_via_request_code(void *context, void *session_info,
                                                   uint8_t request_code)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *spdm_context;

<span style = "background-color:#dfd">    spdm_context = context;</span>
    /**
     * Any request other than SPDM_GET_MEASUREMENTS resets L1/L2
     */
<span style = "background-color:#dfd">    if (request_code != SPDM_GET_MEASUREMENTS) {
        libspdm_reset_message_m(spdm_context, session_info);</span>
    }
    /**
     * If the Requester issued GET_MEASUREMENTS or KEY_EXCHANGE or FINISH or PSK_EXCHANGE
     * or PSK_FINISH or KEY_UPDATE or HEARTBEAT or GET_ENCAPSULATED_REQUEST or DELIVER_ENCAPSULATED_RESPONSE
     * or END_SESSION request(s) and skipped CHALLENGE completion, M1 and M2 are reset to null.
     */
<span style = "background-color:#dfd">    switch (request_code)</span>
    {
    case SPDM_KEY_EXCHANGE:
    case SPDM_GET_MEASUREMENTS:
    case SPDM_FINISH:
    case SPDM_PSK_EXCHANGE:
    case SPDM_PSK_FINISH:
    case SPDM_KEY_UPDATE:
    case SPDM_HEARTBEAT:
    case SPDM_GET_ENCAPSULATED_REQUEST:
    case SPDM_END_SESSION:
<span style = "background-color:#dfd">        if (spdm_context-&gt;connection_info.connection_state &lt;</span>
            LIBSPDM_CONNECTION_STATE_AUTHENTICATED) {
<span style = "background-color:#dfd">            libspdm_reset_message_b(spdm_context);
            libspdm_reset_message_c(spdm_context);
            libspdm_reset_message_mut_b(spdm_context);
            libspdm_reset_message_mut_c(spdm_context);</span>
        }
<span style = "background-color:#dfd">        break;</span>
    case SPDM_DELIVER_ENCAPSULATED_RESPONSE:
<span style = "background-color:#fdd">        if (spdm_context-&gt;connection_info.connection_state &lt;</span>
            LIBSPDM_CONNECTION_STATE_AUTHENTICATED) {
<span style = "background-color:#fdd">            libspdm_reset_message_b(spdm_context);
            libspdm_reset_message_c(spdm_context);</span>
        }
<span style = "background-color:#fdd">        break;</span>
    case SPDM_GET_DIGESTS:
<span style = "background-color:#dfd">        libspdm_reset_message_b(spdm_context);</span>
        break;
    default:
        break;
    }
<span style = "background-color:#dfd">}</span>
/**
 * Append message A cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_a(libspdm_context_t *spdm_context, const void *message,
                                          size_t message_size)
<span style = "background-color:#dfd">{
    return libspdm_append_managed_buffer(&amp;spdm_context-&gt;transcript.message_a,</span>
                                         message, message_size);
<span style = "background-color:#dfd">}</span>

/**
 * Append message D cache in SPDM context.
 *
 * @param  spdm_context  A pointer to the SPDM context.
 * @param  message       Message buffer.
 * @param  message_size  Size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_d(libspdm_context_t *spdm_context, const void *message,
                                          size_t message_size)
<span style = "background-color:#fdd">{</span>
    /* Only the first message D after VCA in connection counts  */
<span style = "background-color:#fdd">    if (libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.message_d) != 0) {
        return LIBSPDM_STATUS_SUCCESS;</span>
    }
<span style = "background-color:#fdd">    return libspdm_append_managed_buffer(&amp;spdm_context-&gt;transcript.message_d,</span>
                                         message, message_size);
<span style = "background-color:#fdd">}</span>

/**
 * Append message B cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_b(libspdm_context_t *spdm_context, const void *message,
                                          size_t message_size)
<span style = "background-color:#dfd">{</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    return libspdm_append_managed_buffer(&amp;spdm_context-&gt;transcript.message_b,
                                         message, message_size);
#else
    {
        bool result;

<span style = "background-color:#dfd">        if (spdm_context-&gt;transcript.digest_context_m1m2 == NULL) {
            spdm_context-&gt;transcript.digest_context_m1m2 = libspdm_hash_new (</span>
                spdm_context-&gt;connection_info.algorithm.base_hash_algo);
<span style = "background-color:#dfd">            if (spdm_context-&gt;transcript.digest_context_m1m2 == NULL) {</span>
<span style = "background-color:#fdd">                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
<span style = "background-color:#dfd">            result = libspdm_hash_init (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                        spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#dfd">            if (!result) {</span>
<span style = "background-color:#fdd">                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                   spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#fdd">                spdm_context-&gt;transcript.digest_context_m1m2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
<span style = "background-color:#dfd">            result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                          spdm_context-&gt;transcript.digest_context_m1m2,
                                          libspdm_get_managed_buffer(&amp;spdm_context-&gt;transcript.
                                                                     message_a),
                                          libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.
                                                                          message_a));
<span style = "background-color:#dfd">            if (!result) {</span>
<span style = "background-color:#fdd">                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                   spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#fdd">                spdm_context-&gt;transcript.digest_context_m1m2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
        }

<span style = "background-color:#dfd">        result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                      spdm_context-&gt;transcript.digest_context_m1m2, message,
                                      message_size);
<span style = "background-color:#dfd">        if (!result) {</span>
<span style = "background-color:#fdd">            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                               spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#fdd">            spdm_context-&gt;transcript.digest_context_m1m2 = NULL;
            return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
        }

<span style = "background-color:#dfd">        return LIBSPDM_STATUS_SUCCESS;</span>
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Append message C cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_c(libspdm_context_t *spdm_context, const void *message,
                                          size_t message_size)
<span style = "background-color:#dfd">{</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    return libspdm_append_managed_buffer(&amp;spdm_context-&gt;transcript.message_c,
                                         message, message_size);
#else
    {
        bool result;

<span style = "background-color:#dfd">        if (spdm_context-&gt;transcript.digest_context_m1m2 == NULL) {
            spdm_context-&gt;transcript.digest_context_m1m2 = libspdm_hash_new (</span>
                spdm_context-&gt;connection_info.algorithm.base_hash_algo);
<span style = "background-color:#dfd">            if (spdm_context-&gt;transcript.digest_context_m1m2 == NULL) {</span>
<span style = "background-color:#fdd">                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
<span style = "background-color:#dfd">            result = libspdm_hash_init (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                        spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#dfd">            if (!result) {</span>
<span style = "background-color:#fdd">                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                   spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#fdd">                spdm_context-&gt;transcript.digest_context_m1m2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
<span style = "background-color:#dfd">            result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                          spdm_context-&gt;transcript.digest_context_m1m2,
                                          libspdm_get_managed_buffer(&amp;spdm_context-&gt;transcript.
                                                                     message_a),
                                          libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.
                                                                          message_a));
<span style = "background-color:#dfd">            if (!result) {</span>
<span style = "background-color:#fdd">                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                   spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#fdd">                spdm_context-&gt;transcript.digest_context_m1m2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
        }

<span style = "background-color:#dfd">        result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                      spdm_context-&gt;transcript.digest_context_m1m2, message,
                                      message_size);
<span style = "background-color:#dfd">        if (!result) {</span>
<span style = "background-color:#fdd">            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                               spdm_context-&gt;transcript.digest_context_m1m2);
<span style = "background-color:#fdd">            spdm_context-&gt;transcript.digest_context_m1m2 = NULL;
            return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
        }

<span style = "background-color:#dfd">        return LIBSPDM_STATUS_SUCCESS;</span>
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Append message MutB cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_mut_b(libspdm_context_t *spdm_context, const void *message,
                                              size_t message_size)
{
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    return libspdm_append_managed_buffer(&amp;spdm_context-&gt;transcript.message_mut_b,
                                         message, message_size);
#else
    {
        bool result;

        if (spdm_context-&gt;transcript.digest_context_mut_m1m2 == NULL) {
            spdm_context-&gt;transcript.digest_context_mut_m1m2 = libspdm_hash_new (
                spdm_context-&gt;connection_info.algorithm.base_hash_algo);
            if (spdm_context-&gt;transcript.digest_context_mut_m1m2 == NULL) {
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            result = libspdm_hash_init (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                        spdm_context-&gt;transcript.digest_context_mut_m1m2);
            if (!result) {
                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                   spdm_context-&gt;transcript.digest_context_mut_m1m2);
                spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            if ((spdm_context-&gt;connection_info.version &gt;&gt; SPDM_VERSION_NUMBER_SHIFT_BIT) &gt;
                SPDM_MESSAGE_VERSION_11) {

                /* Need append VCA since 1.2 script */
                result = libspdm_hash_update (
                    spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                    spdm_context-&gt;transcript.digest_context_mut_m1m2,
                    libspdm_get_managed_buffer(&amp;spdm_context-&gt;transcript.message_a),
                    libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.
                                                    message_a));
                if (!result) {
                    libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                       spdm_context-&gt;transcript.digest_context_mut_m1m2);
                    spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;
                    return LIBSPDM_STATUS_CRYPTO_ERROR;
                }
            }
        }

        result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                      spdm_context-&gt;transcript.digest_context_mut_m1m2, message,
                                      message_size);
        if (!result) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                               spdm_context-&gt;transcript.digest_context_mut_m1m2);
            spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;
            return LIBSPDM_STATUS_CRYPTO_ERROR;
        }

        return LIBSPDM_STATUS_SUCCESS;
    }
#endif
}

/**
 * Append message MutC cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_mut_c(libspdm_context_t *spdm_context, const void *message,
                                              size_t message_size)
{
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    return libspdm_append_managed_buffer(&amp;spdm_context-&gt;transcript.message_mut_c,
                                         message, message_size);
#else
    {
        bool result;

        if (spdm_context-&gt;transcript.digest_context_mut_m1m2 == NULL) {
            spdm_context-&gt;transcript.digest_context_mut_m1m2 = libspdm_hash_new (
                spdm_context-&gt;connection_info.algorithm.base_hash_algo);
            if (spdm_context-&gt;transcript.digest_context_mut_m1m2 == NULL) {
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            result = libspdm_hash_init (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                        spdm_context-&gt;transcript.digest_context_mut_m1m2);
            if (!result) {
                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                   spdm_context-&gt;transcript.digest_context_mut_m1m2);
                spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            if ((spdm_context-&gt;connection_info.version &gt;&gt; SPDM_VERSION_NUMBER_SHIFT_BIT) &gt;
                SPDM_MESSAGE_VERSION_11) {

                /* Need append VCA since 1.2 script */
                result = libspdm_hash_update (
                    spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                    spdm_context-&gt;transcript.digest_context_mut_m1m2,
                    libspdm_get_managed_buffer(&amp;spdm_context-&gt;transcript.message_a),
                    libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.
                                                    message_a));
                if (!result) {
                    libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                       spdm_context-&gt;transcript.digest_context_mut_m1m2);
                    spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;
                    return LIBSPDM_STATUS_CRYPTO_ERROR;
                }
            }
        }

        result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                      spdm_context-&gt;transcript.digest_context_mut_m1m2, message,
                                      message_size);
        if (!result) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                               spdm_context-&gt;transcript.digest_context_mut_m1m2);
            spdm_context-&gt;transcript.digest_context_mut_m1m2 = NULL;
            return LIBSPDM_STATUS_CRYPTO_ERROR;
        }

        return LIBSPDM_STATUS_SUCCESS;
    }
#endif
}

/**
 * Append message M cache in SPDM context.
 * If session_info is NULL, this function will use M cache of SPDM context,
 * else will use M cache of SPDM session context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  session_info                  A pointer to the SPDM session context.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_m(libspdm_context_t *spdm_context, void *session_info,
                                          const void *message, size_t message_size)
<span style = "background-color:#dfd">{</span>
    libspdm_session_info_t *spdm_session_info;

<span style = "background-color:#dfd">    spdm_session_info = session_info;</span>
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    if (spdm_session_info == NULL) {
        return libspdm_append_managed_buffer(&amp;spdm_context-&gt;transcript.message_m,
                                             message, message_size);
    } else {
        return libspdm_append_managed_buffer(&amp;spdm_session_info-&gt;session_transcript.message_m,
                                             message, message_size);
    }
#else
    {
        bool result;

<span style = "background-color:#dfd">        if (spdm_session_info == NULL) {
            if (spdm_context-&gt;transcript.digest_context_l1l2 == NULL) {
                spdm_context-&gt;transcript.digest_context_l1l2 = libspdm_hash_new (</span>
                    spdm_context-&gt;connection_info.algorithm.base_hash_algo);
<span style = "background-color:#dfd">                if (spdm_context-&gt;transcript.digest_context_l1l2 == NULL) {</span>
<span style = "background-color:#fdd">                    return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
                }
<span style = "background-color:#dfd">                result = libspdm_hash_init (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                            spdm_context-&gt;transcript.digest_context_l1l2);
<span style = "background-color:#dfd">                if (!result) {</span>
<span style = "background-color:#fdd">                    libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                       spdm_context-&gt;transcript.digest_context_l1l2);
<span style = "background-color:#fdd">                    spdm_context-&gt;transcript.digest_context_l1l2 = NULL;
                    return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
                }
<span style = "background-color:#dfd">                if ((spdm_context-&gt;connection_info.version &gt;&gt; SPDM_VERSION_NUMBER_SHIFT_BIT) &gt;</span>
                    SPDM_MESSAGE_VERSION_11) {

                    /* Need append VCA since 1.2 script */
<span style = "background-color:#dfd">                    result = libspdm_hash_update (</span>
                        spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                        spdm_context-&gt;transcript.digest_context_l1l2,
                        libspdm_get_managed_buffer(
                            &amp;spdm_context-&gt;transcript.message_a),
                        libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.
                                                        message_a));
<span style = "background-color:#dfd">                    if (!result) {</span>
<span style = "background-color:#fdd">                        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                           spdm_context-&gt;transcript.digest_context_l1l2);
<span style = "background-color:#fdd">                        spdm_context-&gt;transcript.digest_context_l1l2 = NULL;
                        return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
                    }
                }
            }
<span style = "background-color:#dfd">            result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                          spdm_context-&gt;transcript.digest_context_l1l2, message,
                                          message_size);
<span style = "background-color:#dfd">            if (!result) {</span>
<span style = "background-color:#fdd">                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                   spdm_context-&gt;transcript.digest_context_l1l2);
<span style = "background-color:#fdd">                spdm_context-&gt;transcript.digest_context_l1l2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
<span style = "background-color:#dfd">        } else {</span>
<span style = "background-color:#fdd">            if (spdm_session_info-&gt;session_transcript.digest_context_l1l2 == NULL) {
                spdm_session_info-&gt;session_transcript.digest_context_l1l2 = libspdm_hash_new (</span>
                    spdm_context-&gt;connection_info.algorithm.base_hash_algo);
<span style = "background-color:#fdd">                if (spdm_session_info-&gt;session_transcript.digest_context_l1l2 == NULL) {
                    return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
                }
<span style = "background-color:#fdd">                result = libspdm_hash_init (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                            spdm_session_info-&gt;session_transcript.digest_context_l1l2);
<span style = "background-color:#fdd">                if (!result) {
                    libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                       spdm_session_info-&gt;session_transcript.digest_context_l1l2);
<span style = "background-color:#fdd">                    spdm_session_info-&gt;session_transcript.digest_context_l1l2 = NULL;
                    return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
                }
<span style = "background-color:#fdd">                if ((spdm_context-&gt;connection_info.version &gt;&gt; SPDM_VERSION_NUMBER_SHIFT_BIT) &gt;</span>
                    SPDM_MESSAGE_VERSION_11) {

                    /* Need append VCA since 1.2 script*/

<span style = "background-color:#fdd">                    result = libspdm_hash_update (</span>
                        spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                        spdm_session_info-&gt;session_transcript.digest_context_l1l2,
                        libspdm_get_managed_buffer(
                            &amp;spdm_context-&gt;transcript.message_a),
                        libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.
                                                        message_a));
<span style = "background-color:#fdd">                    if (!result) {
                        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                           spdm_session_info-&gt;session_transcript.digest_context_l1l2);
<span style = "background-color:#fdd">                        spdm_session_info-&gt;session_transcript.digest_context_l1l2 = NULL;
                        return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
                    }
                }
            }
<span style = "background-color:#fdd">            result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                          spdm_session_info-&gt;session_transcript.digest_context_l1l2,
                                          message, message_size);
<span style = "background-color:#fdd">            if (!result) {
                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,</span>
                                   spdm_session_info-&gt;session_transcript.digest_context_l1l2);
<span style = "background-color:#fdd">                spdm_session_info-&gt;session_transcript.digest_context_l1l2 = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
            }
        }

<span style = "background-color:#dfd">        return LIBSPDM_STATUS_SUCCESS;</span>
    }
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Append message K cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  spdm_session_info              A pointer to the SPDM session context.
 * @param  is_requester                  Indicate of the key generation for a requester or a responder.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_k(libspdm_context_t *spdm_context,
                                          void *session_info,
                                          bool is_requester, const void *message,
                                          size_t message_size)
{
    libspdm_session_info_t *spdm_session_info;

    spdm_session_info = session_info;
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    return libspdm_append_managed_buffer(
        &amp;spdm_session_info-&gt;session_transcript.message_k, message,
        message_size);
#else
    {
        uint8_t *cert_chain_buffer;
        size_t cert_chain_buffer_size;
        bool result;
        uint8_t cert_chain_buffer_hash[LIBSPDM_MAX_HASH_SIZE];
        uint32_t hash_size;
        uint8_t slot_id;

        hash_size = libspdm_get_hash_size(spdm_context-&gt;connection_info.algorithm.base_hash_algo);

        if (spdm_session_info-&gt;session_transcript.digest_context_th == NULL) {
            if (!spdm_session_info-&gt;use_psk) {
                if (is_requester) {
                    slot_id = spdm_context-&gt;connection_info.peer_used_cert_chain_slot_id;
                    LIBSPDM_ASSERT((slot_id &lt; SPDM_MAX_SLOT_COUNT) || (slot_id == 0xFF));
                    if (slot_id == 0xFF) {
                        result = libspdm_get_peer_public_key_buffer(
                            spdm_context, (const void **)&amp;cert_chain_buffer,
                            &amp;cert_chain_buffer_size);
                        if (!result) {
                            return LIBSPDM_STATUS_INVALID_STATE_PEER;
                        }

                        result = libspdm_hash_all(
                            spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                            cert_chain_buffer, cert_chain_buffer_size,
                            cert_chain_buffer_hash);
                        if (!result) {
                            return LIBSPDM_STATUS_CRYPTO_ERROR;
                        }
                    } else {
                        LIBSPDM_ASSERT(
                            hash_size ==
                            spdm_context-&gt;connection_info
                            .peer_used_cert_chain[slot_id].buffer_hash_size);

                        libspdm_copy_mem(cert_chain_buffer_hash,
                                         sizeof(cert_chain_buffer_hash),
                                         spdm_context-&gt;connection_info
                                         .peer_used_cert_chain[slot_id].buffer_hash,
                                         hash_size);
                    }
                } else {
                    slot_id = spdm_context-&gt;connection_info.local_used_cert_chain_slot_id;
                    LIBSPDM_ASSERT((slot_id &lt; SPDM_MAX_SLOT_COUNT) || (slot_id == 0xFF));
                    if (slot_id == 0xFF) {
                        result = libspdm_get_local_public_key_buffer(
                            spdm_context, (const void **)&amp;cert_chain_buffer,
                            &amp;cert_chain_buffer_size);
                    } else {
                        result = libspdm_get_local_cert_chain_buffer(
                            spdm_context, (const void **)&amp;cert_chain_buffer,
                            &amp;cert_chain_buffer_size);
                    }
                    if (!result) {
                        return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
                    }

                    result = libspdm_hash_all(
                        spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                        cert_chain_buffer, cert_chain_buffer_size,
                        cert_chain_buffer_hash);
                    if (!result) {
                        return LIBSPDM_STATUS_CRYPTO_ERROR;
                    }
                }
            }
        }


        /* prepare digest_context_th*/

        if (spdm_session_info-&gt;session_transcript.digest_context_th == NULL) {
            spdm_session_info-&gt;session_transcript.digest_context_th = libspdm_hash_new (
                spdm_context-&gt;connection_info.algorithm.base_hash_algo);
            if (spdm_session_info-&gt;session_transcript.digest_context_th == NULL) {
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            result = libspdm_hash_init (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                        spdm_session_info-&gt;session_transcript.digest_context_th);
            if (!result) {
                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                   spdm_session_info-&gt;session_transcript.digest_context_th);
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                          spdm_session_info-&gt;session_transcript.digest_context_th,
                                          libspdm_get_managed_buffer(&amp;spdm_context-&gt;transcript.
                                                                     message_a),
                                          libspdm_get_managed_buffer_size(
                                              &amp;spdm_context-&gt;transcript.message_a));
            if (!result) {
                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                   spdm_session_info-&gt;session_transcript.digest_context_th);
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            if (!spdm_session_info-&gt;use_psk) {
                if (spdm_context-&gt;connection_info.multi_key_conn_rsp) {
                    result = libspdm_hash_update (
                        spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                        spdm_session_info-&gt;session_transcript.digest_context_th,
                        libspdm_get_managed_buffer(&amp;spdm_context-&gt;transcript.message_d),
                        libspdm_get_managed_buffer_size(&amp;spdm_context-&gt;transcript.message_d));
                    if (!result) {
                        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                           spdm_session_info-&gt;session_transcript.digest_context_th);
                        return LIBSPDM_STATUS_CRYPTO_ERROR;
                    }
                }

                result = libspdm_hash_update (
                    spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                    spdm_session_info-&gt;session_transcript.digest_context_th,
                    cert_chain_buffer_hash, hash_size);
                if (!result) {
                    libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                       spdm_session_info-&gt;session_transcript.digest_context_th);
                    return LIBSPDM_STATUS_CRYPTO_ERROR;
                }
            }
        }
        result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                      spdm_session_info-&gt;session_transcript.digest_context_th,
                                      message,
                                      message_size);
        if (!result) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                               spdm_session_info-&gt;session_transcript.digest_context_th);
            return LIBSPDM_STATUS_CRYPTO_ERROR;
        }
        return LIBSPDM_STATUS_SUCCESS;
    }
#endif
}

/**
 * Append message EncapD cache in SPDM context.
 *
 * @param  spdm_context       A pointer to the SPDM context.
 * @param  spdm_session_info  A pointer to the SPDM session context.
 * @param  is_requester       Indicate of the key generation for a requester or a responder.
 * @param  message            Message buffer.
 * @param  message_size       Size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_encap_d(libspdm_context_t *spdm_context,
                                                void *session_info,
                                                bool is_requester, const void *message,
                                                size_t message_size)
{
    libspdm_session_info_t *spdm_session_info;

    spdm_session_info = session_info;
    /* Only the first message EncapD in current session counts  */
    if (libspdm_get_managed_buffer_size(&amp;spdm_session_info-&gt;session_transcript.message_encap_d) !=
        0) {
        return LIBSPDM_STATUS_SUCCESS;
    }
    return libspdm_append_managed_buffer(
        &amp;spdm_session_info-&gt;session_transcript.message_encap_d, message,
        message_size);
}

/**
 * Append message F cache in SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  spdm_session_info              A pointer to the SPDM session context.
 * @param  is_requester                  Indicate of the key generation for a requester or a responder.
 * @param  message                      message buffer.
 * @param  message_size                  size in bytes of message buffer.
 *
 * @return RETURN_SUCCESS          message is appended.
 * @return RETURN_OUT_OF_RESOURCES message is not appended because the internal cache is full.
 **/
libspdm_return_t libspdm_append_message_f(libspdm_context_t *spdm_context,
                                          void *session_info,
                                          bool is_requester, const void *message,
                                          size_t message_size)
{
    libspdm_session_info_t *spdm_session_info;

    spdm_session_info = session_info;
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    return libspdm_append_managed_buffer(
        &amp;spdm_session_info-&gt;session_transcript.message_f, message,
        message_size);
#else
    {
        const uint8_t *mut_cert_chain_buffer;
        size_t mut_cert_chain_buffer_size;
        bool result;
        uint8_t mut_cert_chain_buffer_hash[LIBSPDM_MAX_HASH_SIZE];
        uint32_t hash_size;
        libspdm_return_t status;
        uint8_t slot_id;

        hash_size = libspdm_get_hash_size(spdm_context-&gt;connection_info.algorithm.base_hash_algo);

        if (!spdm_session_info-&gt;session_transcript.message_f_initialized) {
            /* digest_context_th might be NULL in unit test, where message_k is hardcoded. */
            if (spdm_session_info-&gt;session_transcript.digest_context_th == NULL) {
                status =
                    libspdm_append_message_k (spdm_context, session_info, is_requester, NULL, 0);
                if (LIBSPDM_STATUS_IS_ERROR(status)) {
                    return status;
                }
            }

            if (!spdm_session_info-&gt;use_psk &amp;&amp; spdm_session_info-&gt;mut_auth_requested) {
                if (is_requester) {
                    slot_id = spdm_context-&gt;connection_info.local_used_cert_chain_slot_id;
                    LIBSPDM_ASSERT((slot_id &lt; SPDM_MAX_SLOT_COUNT) || (slot_id == 0xFF));
                    if (slot_id == 0xFF) {
                        result = libspdm_get_local_public_key_buffer(
                            spdm_context,
                            (const void **)&amp;mut_cert_chain_buffer,
                            &amp;mut_cert_chain_buffer_size);
                    } else {
                        result = libspdm_get_local_cert_chain_buffer(
                            spdm_context,
                            (const void **)&amp;mut_cert_chain_buffer,
                            &amp;mut_cert_chain_buffer_size);
                    }
                    if (!result) {
                        return LIBSPDM_STATUS_INVALID_STATE_LOCAL;
                    }

                    result = libspdm_hash_all(
                        spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                        mut_cert_chain_buffer, mut_cert_chain_buffer_size,
                        mut_cert_chain_buffer_hash);
                    if (!result) {
                        return LIBSPDM_STATUS_CRYPTO_ERROR;
                    }
                } else {
                    slot_id = spdm_context-&gt;connection_info.peer_used_cert_chain_slot_id;
                    LIBSPDM_ASSERT((slot_id &lt; SPDM_MAX_SLOT_COUNT) || (slot_id == 0xFF));
                    if (slot_id == 0xFF) {
                        result = libspdm_get_peer_public_key_buffer(
                            spdm_context,
                            (const void **)&amp;mut_cert_chain_buffer,
                            &amp;mut_cert_chain_buffer_size);
                        if (!result) {
                            return LIBSPDM_STATUS_INVALID_STATE_PEER;
                        }

                        result = libspdm_hash_all(
                            spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                            mut_cert_chain_buffer, mut_cert_chain_buffer_size,
                            mut_cert_chain_buffer_hash);
                        if (!result) {
                            return LIBSPDM_STATUS_CRYPTO_ERROR;
                        }
                    } else {
                        LIBSPDM_ASSERT(
                            hash_size ==
                            spdm_context-&gt;connection_info
                            .peer_used_cert_chain[slot_id].buffer_hash_size);

                        libspdm_copy_mem(mut_cert_chain_buffer_hash,
                                         sizeof(mut_cert_chain_buffer_hash),
                                         spdm_context-&gt;connection_info
                                         .peer_used_cert_chain[slot_id].buffer_hash,
                                         hash_size);
                    }
                }
            }

            /* It is first time call, backup current message_k context
             * this backup will be used in reset_message_f.*/

            LIBSPDM_ASSERT (spdm_session_info-&gt;session_transcript.digest_context_th != NULL);
            spdm_session_info-&gt;session_transcript.digest_context_th_backup = libspdm_hash_new (
                spdm_context-&gt;connection_info.algorithm.base_hash_algo);
            if (spdm_session_info-&gt;session_transcript.digest_context_th_backup == NULL) {
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
            result = libspdm_hash_duplicate (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                             spdm_session_info-&gt;session_transcript.digest_context_th,
                                             spdm_session_info-&gt;session_transcript.digest_context_th_backup);
            if (!result) {
                libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                   spdm_session_info-&gt;session_transcript.digest_context_th_backup);
                spdm_session_info-&gt;session_transcript.digest_context_th_backup = NULL;
                return LIBSPDM_STATUS_CRYPTO_ERROR;
            }
        }


        /* prepare digest_context_th*/

        LIBSPDM_ASSERT (spdm_session_info-&gt;session_transcript.digest_context_th != NULL);
        if (!spdm_session_info-&gt;session_transcript.message_f_initialized) {
            if (!spdm_session_info-&gt;use_psk &amp;&amp; spdm_session_info-&gt;mut_auth_requested) {
                if (spdm_context-&gt;connection_info.multi_key_conn_req) {
                    result = libspdm_hash_update (
                        spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                        spdm_session_info-&gt;session_transcript.digest_context_th,
                        libspdm_get_managed_buffer(&amp;spdm_session_info-&gt;session_transcript.
                                                   message_encap_d),
                        libspdm_get_managed_buffer_size(&amp;spdm_session_info-&gt;session_transcript.
                                                        message_encap_d));
                    if (!result) {
                        libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                           spdm_session_info-&gt;session_transcript.digest_context_th);
                        spdm_session_info-&gt;session_transcript.digest_context_th = NULL;
                        return LIBSPDM_STATUS_CRYPTO_ERROR;
                    }
                }

                result = libspdm_hash_update (
                    spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                    spdm_session_info-&gt;session_transcript.digest_context_th,
                    mut_cert_chain_buffer_hash, hash_size);
                if (!result) {
                    libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                       spdm_session_info-&gt;session_transcript.digest_context_th);
                    spdm_session_info-&gt;session_transcript.digest_context_th = NULL;
                    return LIBSPDM_STATUS_CRYPTO_ERROR;
                }
            }
        }
        result = libspdm_hash_update (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                                      spdm_session_info-&gt;session_transcript.digest_context_th,
                                      message,
                                      message_size);
        if (!result) {
            libspdm_hash_free (spdm_context-&gt;connection_info.algorithm.base_hash_algo,
                               spdm_session_info-&gt;session_transcript.digest_context_th);
            spdm_session_info-&gt;session_transcript.digest_context_th = NULL;
            return LIBSPDM_STATUS_CRYPTO_ERROR;
        }

        spdm_session_info-&gt;session_transcript.message_f_initialized = true;
        return LIBSPDM_STATUS_SUCCESS;
    }
#endif
}

/**
 * This function returns if a given version is supported based upon the GET_VERSION/VERSION.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  version                      The SPDM version.
 *
 * @retval true  the version is supported.
 * @retval false the version is not supported.
 **/
bool libspdm_is_version_supported(const libspdm_context_t *spdm_context, uint8_t version)
{
    if (version == (spdm_context-&gt;connection_info.version &gt;&gt; SPDM_VERSION_NUMBER_SHIFT_BIT)) {
        return true;
    }

    return false;
}

/**
 * This function returns connection version negotiated by GET_VERSION/VERSION.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 *
 * @return the connection version.
 **/
uint8_t libspdm_get_connection_version(const libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{
    return (uint8_t)(spdm_context-&gt;connection_info.version &gt;&gt; SPDM_VERSION_NUMBER_SHIFT_BIT);
}</span>

/**
 * This function returns if a capabilities flag is supported in current SPDM connection.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  is_requester                  Is the function called from a requester.
 * @param  requester_capabilities_flag    The requester capabilities flag to be checked
 * @param  responder_capabilities_flag    The responder capabilities flag to be checked
 *
 * @retval true  the capabilities flag is supported.
 * @retval false the capabilities flag is not supported.
 **/
bool libspdm_is_capabilities_flag_supported(const libspdm_context_t *spdm_context,
                                            bool is_requester,
                                            uint32_t requester_capabilities_flag,
                                            uint32_t responder_capabilities_flag)
<span style = "background-color:#dfd">{</span>
    uint32_t negotiated_requester_capabilities_flag;
    uint32_t negotiated_responder_capabilities_flag;

<span style = "background-color:#dfd">    if (is_requester) {
        negotiated_requester_capabilities_flag = spdm_context-&gt;local_context.capability.flags;
        negotiated_responder_capabilities_flag = spdm_context-&gt;connection_info.capability.flags;
    } else {
        negotiated_requester_capabilities_flag = spdm_context-&gt;connection_info.capability.flags;
        negotiated_responder_capabilities_flag = spdm_context-&gt;local_context.capability.flags;</span>
    }

    if (((requester_capabilities_flag == 0) ||
         ((negotiated_requester_capabilities_flag &amp;
<span style = "background-color:#dfd">           requester_capabilities_flag) != 0)) &amp;&amp;</span>
        ((responder_capabilities_flag == 0) ||
         ((negotiated_responder_capabilities_flag &amp;
           responder_capabilities_flag) != 0))) {
<span style = "background-color:#dfd">        return true;</span>
<span style = "background-color:#fdd">    } else {</span>
<span style = "background-color:#dfd">        return false;</span>
    }
<span style = "background-color:#dfd">}</span>

bool libspdm_is_encap_supported(const libspdm_context_t *spdm_context)
{
    if (libspdm_get_connection_version(spdm_context) == SPDM_MESSAGE_VERSION_10) {
        return false;
    } else if (libspdm_get_connection_version(spdm_context) == SPDM_MESSAGE_VERSION_12) {
        /* ENCAP_CAP was erroneously deprecated in SPDM 1.2.0 and 1.2.1, and MUT_AUTH_CAP
         * was used in its place. In SPDM 1.2.2 and later ENCAP_CAP is undeprecated. Since
         * UpdateVersionNumber must be ignored when checking interoperability libspdm will check
         * if ENCAP_CAP or MUT_AUTH_CAP is set. */
        const bool is_req_encap_cap_supported = libspdm_is_capabilities_flag_supported(
            spdm_context, spdm_context-&gt;local_context.is_requester,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_ENCAP_CAP, 0);
        const bool is_req_mut_auth_cap_supported = libspdm_is_capabilities_flag_supported(
            spdm_context, spdm_context-&gt;local_context.is_requester,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_MUT_AUTH_CAP, 0);
        const bool is_rsp_encap_cap_supported = libspdm_is_capabilities_flag_supported(
            spdm_context, spdm_context-&gt;local_context.is_requester,
            0, SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_ENCAP_CAP);
        const bool is_rsp_mut_auth_cap_supported = libspdm_is_capabilities_flag_supported(
            spdm_context, spdm_context-&gt;local_context.is_requester,
            0, SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MUT_AUTH_CAP);

        return ((is_req_encap_cap_supported || is_req_mut_auth_cap_supported) &amp;&amp;
                (is_rsp_encap_cap_supported || is_rsp_mut_auth_cap_supported));
    } else {
        /* For SPDM 1.1 and 1.3 and later only check ENCAP_CAP. */
        return libspdm_is_capabilities_flag_supported(
            spdm_context, spdm_context-&gt;local_context.is_requester,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_ENCAP_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_ENCAP_CAP);
    }
}

/**
 * Register SPDM device input/output functions.
 *
 * This function must be called after libspdm_init_context, and before any SPDM communication.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  send_message                  The fuction to send an SPDM transport layer message.
 * @param  receive_message               The fuction to receive an SPDM transport layer message.
 **/
void libspdm_register_device_io_func(
    void *spdm_context, libspdm_device_send_message_func send_message,
    libspdm_device_receive_message_func receive_message)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;

<span style = "background-color:#dfd">    context = spdm_context;
    context-&gt;send_message = send_message;
    context-&gt;receive_message = receive_message;
}</span>

/**
 * Register SPDM device buffer management functions.
 *
 * This function must be called after libspdm_init_context, and before any SPDM communication.
 *
 * The sender_buffer_size and receiver_buffer_size must be no smaller than
 * MAX (non-secure Transport Message Header Size +
 *          SPDM_CAPABILITIES.DataTransferSize +
 *          max alignment pad size (transport specific),
 *      secure Transport Message Header Size +
 *          sizeof(spdm_secured_message_a_data_header1_t) +
 *          length of sequence_number (transport specific) +
 *          sizeof(spdm_secured_message_a_data_header2_t) +
 *          sizeof(spdm_secured_message_cipher_header_t) +
 *          App Message Header Size (transport specific) +
 *          SPDM_CAPABILITIES.DataTransferSize +
 *          maximum random data size (transport specific) +
 *          AEAD MAC size (16) +
 *          max alignment pad size (transport specific)).
 *
 * Finally, the SPDM_CAPABILITIES.DataTransferSize will be calculated based upon it.
 *
 *   For MCTP,
 *          Transport Message Header Size = sizeof(mctp_message_header_t)
 *          length of sequence_number = 2
 *          App Message Header Size = sizeof(mctp_message_header_t)
 *          maximum random data size = MCTP_MAX_RANDOM_NUMBER_COUNT
 *          max alignment pad size = 0
 *   For PCI_DOE,
 *          Transport Message Header Size = sizeof(pci_doe_data_object_header_t)
 *          length of sequence_number = 0
 *          App Message Header Size = 0
 *          maximum random data size = 0
 *          max alignment pad size = 3
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  sender_buffer_size            Size in bytes of the sender buffer.
 * @param  receiver_buffer_size          Size in bytes of the receiver buffer.
 * @param  acquire_sender_buffer         The fuction to acquire transport layer sender buffer.
 * @param  release_sender_buffer         The fuction to release transport layer sender buffer.
 * @param  acquire_receiver_buffer       The fuction to acquire transport layer receiver buffer.
 * @param  release_receiver_buffer       The fuction to release transport layer receiver buffer.
 **/
void libspdm_register_device_buffer_func(
    void *spdm_context,
    uint32_t sender_buffer_size,
    uint32_t receiver_buffer_size,
    libspdm_device_acquire_sender_buffer_func acquire_sender_buffer,
    libspdm_device_release_sender_buffer_func release_sender_buffer,
    libspdm_device_acquire_receiver_buffer_func acquire_receiver_buffer,
    libspdm_device_release_receiver_buffer_func release_receiver_buffer)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;

<span style = "background-color:#dfd">    context = spdm_context;
    context-&gt;sender_buffer_size = sender_buffer_size;
    context-&gt;receiver_buffer_size = receiver_buffer_size;
    context-&gt;acquire_sender_buffer = acquire_sender_buffer;
    context-&gt;release_sender_buffer = release_sender_buffer;
    context-&gt;acquire_receiver_buffer = acquire_receiver_buffer;
    context-&gt;release_receiver_buffer = release_receiver_buffer;</span>

<span style = "background-color:#dfd">    LIBSPDM_ASSERT (sender_buffer_size &gt;=</span>
                    context-&gt;local_context.capability.transport_header_size +
                    context-&gt;local_context.capability.transport_tail_size);
<span style = "background-color:#dfd">    sender_buffer_size -= (context-&gt;local_context.capability.transport_header_size +</span>
                           context-&gt;local_context.capability.transport_tail_size);
<span style = "background-color:#dfd">    LIBSPDM_ASSERT (sender_buffer_size &gt;= SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12);
    context-&gt;local_context.capability.sender_data_transfer_size = sender_buffer_size;</span>

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(receiver_buffer_size &gt;=</span>
                   context-&gt;local_context.capability.transport_header_size +
                   context-&gt;local_context.capability.transport_tail_size);
<span style = "background-color:#dfd">    receiver_buffer_size -= (context-&gt;local_context.capability.transport_header_size +</span>
                             context-&gt;local_context.capability.transport_tail_size);
<span style = "background-color:#dfd">    LIBSPDM_ASSERT (receiver_buffer_size &gt;= SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12);
    context-&gt;local_context.capability.data_transfer_size = receiver_buffer_size;
}</span>

/**
 * Register SPDM transport layer encode/decode functions for SPDM or APP messages.
 *
 * This function must be called after libspdm_init_context, and before any SPDM communication.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  transport_encode_message       The fuction to encode an SPDM or APP message to a transport layer message.
 * @param  transport_decode_message       The fuction to decode an SPDM or APP message from a transport layer message.
 **/
void libspdm_register_transport_layer_func(
    void *spdm_context,
    uint32_t max_spdm_msg_size,
    uint32_t transport_header_size,
    uint32_t transport_tail_size,
    libspdm_transport_encode_message_func transport_encode_message,
    libspdm_transport_decode_message_func transport_decode_message)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;

<span style = "background-color:#dfd">    context = spdm_context;</span>

    /* fix the data_transfer_size if it is set before */
<span style = "background-color:#dfd">    if ((context-&gt;local_context.capability.data_transfer_size != 0) &amp;&amp;</span>
        (context-&gt;local_context.capability.data_transfer_size ==
         context-&gt;receiver_buffer_size)) {
<span style = "background-color:#fdd">        context-&gt;local_context.capability.data_transfer_size =</span>
            (uint32_t)(context-&gt;receiver_buffer_size -
                       (transport_header_size + transport_tail_size));
    }
<span style = "background-color:#dfd">    if ((context-&gt;local_context.capability.sender_data_transfer_size != 0) &amp;&amp;</span>
        (context-&gt;local_context.capability.sender_data_transfer_size ==
         context-&gt;sender_buffer_size)) {
<span style = "background-color:#fdd">        context-&gt;local_context.capability.sender_data_transfer_size =</span>
            (uint32_t)(context-&gt;sender_buffer_size -
                       (transport_header_size + transport_tail_size));
    }

<span style = "background-color:#dfd">    context-&gt;local_context.capability.max_spdm_msg_size = max_spdm_msg_size;
    context-&gt;local_context.capability.transport_header_size = transport_header_size;
    context-&gt;local_context.capability.transport_tail_size = transport_tail_size;
    context-&gt;transport_encode_message = transport_encode_message;
    context-&gt;transport_decode_message = transport_decode_message;
}</span>

/**
 * Register SPDM certificate verification functions for SPDM GET_CERTIFICATE in requester or responder.
 * It is called after GET_CERTIFICATE gets a full certificate chain from peer.
 *
 * If it is NOT registered, the default verification in SPDM lib will be used. It verifies:
 *    1) The integrity of the certificate chain, (Root Cert Hash-&gt;Root Cert-&gt;Cert Chain), according to X.509.
 *  2) The trust anchor, according LIBSPDM_DATA_PEER_PUBLIC_ROOT_CERT or LIBSPDM_DATA_PEER_PUBLIC_CERT_CHAIN.
 * If it is registered, SPDM lib will use this function to verify the certificate.
 *
 * This function must be called after libspdm_init_context, and before any SPDM communication.
 *
 * @param  context                  A pointer to the SPDM context.
 * @param  verify_spdm_cert_chain   The fuction to verify an SPDM certificate after GET_CERTIFICATE.
 **/
void libspdm_register_verify_spdm_cert_chain_func(
    void *spdm_context,
    const libspdm_verify_spdm_cert_chain_func verify_spdm_cert_chain)
{
    libspdm_context_t *context;

    context = spdm_context;
    context-&gt;local_context.verify_peer_spdm_cert_chain = verify_spdm_cert_chain;
}

/**
 * Get the size of required scratch buffer.
 *
 * The SPDM Integrator must call libspdm_get_sizeof_required_scratch_buffer to get the size,
 * then allocate enough scratch buffer and call libspdm_set_scratch_buffer().
 *
 * @param  context                  A pointer to the SPDM context.
 *
 * @return the size of required scratch buffer.
 **/
size_t libspdm_get_sizeof_required_scratch_buffer (void *spdm_context)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    size_t scratch_buffer_size;

<span style = "background-color:#dfd">    context = spdm_context;
    LIBSPDM_ASSERT (context-&gt;local_context.capability.max_spdm_msg_size != 0);</span>

<span style = "background-color:#dfd">    scratch_buffer_size = libspdm_get_scratch_buffer_capacity(context);
    return scratch_buffer_size;
}</span>

/**
 * Set the scratch buffer.
 *
 * This function must be called after libspdm_init_context, and before any SPDM communication.
 *
 * @param  context                  A pointer to the SPDM context.
 * @param  scratch_buffer           Buffer address of the scratch buffer.
 * @param  scratch_buffer_size      Size of the scratch buffer.
 *
 **/
void libspdm_set_scratch_buffer (
    void *spdm_context,
    void *scratch_buffer,
    size_t scratch_buffer_size)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;

<span style = "background-color:#dfd">    context = spdm_context;
    LIBSPDM_ASSERT (context-&gt;local_context.capability.max_spdm_msg_size != 0);
    LIBSPDM_ASSERT (scratch_buffer_size &gt;= libspdm_get_scratch_buffer_capacity(spdm_context));
    context-&gt;scratch_buffer = scratch_buffer;
    context-&gt;scratch_buffer_size = scratch_buffer_size;
    context-&gt;last_spdm_request = (uint8_t *)scratch_buffer +</span>
                                 libspdm_get_scratch_buffer_last_spdm_request_offset(spdm_context);
#if LIBSPDM_RESPOND_IF_READY_SUPPORT
<span style = "background-color:#dfd">    context-&gt;cache_spdm_request = (uint8_t *)scratch_buffer +</span>
                                  libspdm_get_scratch_buffer_cache_spdm_request_offset(spdm_context);
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Get the scratch buffer.
 *
 * @param  context                  A pointer to the SPDM context.
 * @param  scratch_buffer           Buffer address of the scratch buffer.
 * @param  scratch_buffer_size      Size of the scratch buffer.
 *
 **/
void libspdm_get_scratch_buffer (
    void *spdm_context,
    void **scratch_buffer,
    size_t *scratch_buffer_size)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;

<span style = "background-color:#dfd">    context = spdm_context;
    LIBSPDM_ASSERT (context-&gt;scratch_buffer != NULL);
    LIBSPDM_ASSERT (context-&gt;scratch_buffer_size &gt;=</span>
                    libspdm_get_scratch_buffer_capacity(spdm_context));
<span style = "background-color:#dfd">    *scratch_buffer = context-&gt;scratch_buffer;
    *scratch_buffer_size = context-&gt;scratch_buffer_size;</span>
    /* need to remove last 2 sections, because they are for libspdm internal state track. */
<span style = "background-color:#dfd">    *scratch_buffer_size -= libspdm_get_scratch_buffer_last_spdm_request_capacity(spdm_context);</span>
#if LIBSPDM_RESPOND_IF_READY_SUPPORT
<span style = "background-color:#dfd">    *scratch_buffer_size -= libspdm_get_scratch_buffer_cache_spdm_request_capacity(spdm_context);</span>
#endif
<span style = "background-color:#dfd">}</span>

/**
 * Acquire a device sender buffer for transport layer message.
 *
 * @param  context                       A pointer to the SPDM context.
 * @param  msg_buf_ptr                   A pointer to a sender buffer.
 *
 * @retval RETURN_SUCCESS               The sender buffer is acquired.
 **/
libspdm_return_t libspdm_acquire_sender_buffer (
    libspdm_context_t *spdm_context, size_t *max_msg_size, void **msg_buf_ptr)
<span style = "background-color:#dfd">{</span>
    libspdm_return_t status;

<span style = "background-color:#dfd">    LIBSPDM_ASSERT (spdm_context-&gt;sender_buffer == NULL);
    LIBSPDM_ASSERT (spdm_context-&gt;sender_buffer_size != 0);
    status = spdm_context-&gt;acquire_sender_buffer (spdm_context, msg_buf_ptr);
    if (status != LIBSPDM_STATUS_SUCCESS) {</span>
<span style = "background-color:#fdd">        return status;</span>
    }
<span style = "background-color:#dfd">    spdm_context-&gt;sender_buffer = *msg_buf_ptr;
    *max_msg_size = spdm_context-&gt;sender_buffer_size;</span>
    #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
    /* it return scratch buffer, because the requester need build message there.*/
    *msg_buf_ptr = spdm_context-&gt;scratch_buffer +
                   libspdm_get_scratch_buffer_large_sender_receiver_offset(spdm_context);
    *max_msg_size = libspdm_get_scratch_buffer_large_sender_receiver_capacity(spdm_context);
    #endif
<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

/**
 * Release a device sender buffer for transport layer message.
 *
 * @param  context                       A pointer to the SPDM context.
 *
 * @retval RETURN_SUCCESS               The sender buffer is Released.
 **/
void libspdm_release_sender_buffer (libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{
    LIBSPDM_ASSERT(spdm_context-&gt;sender_buffer != NULL);
    LIBSPDM_ASSERT(spdm_context-&gt;sender_buffer_size != 0);</span>

<span style = "background-color:#dfd">    spdm_context-&gt;release_sender_buffer (spdm_context, spdm_context-&gt;sender_buffer);
    spdm_context-&gt;sender_buffer = NULL;
}</span>

/**
 * Get the sender buffer.
 *
 * @param  context                  A pointer to the SPDM context.
 * @param  receiver_buffer            Buffer address of the sender buffer.
 * @param  receiver_buffer_size       Size of the sender buffer.
 *
 **/
void libspdm_get_sender_buffer (
    libspdm_context_t *spdm_context,
    void **sender_buffer,
    size_t *sender_buffer_size)
<span style = "background-color:#dfd">{
    *sender_buffer = spdm_context-&gt;sender_buffer;
    *sender_buffer_size = spdm_context-&gt;sender_buffer_size;
}</span>

/**
 * Acquire a device receiver buffer for transport layer message.
 *
 * @param  context                       A pointer to the SPDM context.
 * @param  max_msg_size                  size in bytes of the maximum size of receiver buffer.
 * @param  msg_buf_pt                    A pointer to a receiver buffer.
 *
 * @retval RETURN_SUCCESS               The receiver buffer is acquired.
 **/
libspdm_return_t libspdm_acquire_receiver_buffer (
    libspdm_context_t *spdm_context, size_t *max_msg_size, void **msg_buf_ptr)
<span style = "background-color:#dfd">{</span>
    libspdm_return_t status;

<span style = "background-color:#dfd">    LIBSPDM_ASSERT (spdm_context-&gt;receiver_buffer == NULL);
    LIBSPDM_ASSERT (spdm_context-&gt;receiver_buffer_size != 0);
    status = spdm_context-&gt;acquire_receiver_buffer (spdm_context, msg_buf_ptr);
    if (status != LIBSPDM_STATUS_SUCCESS) {</span>
<span style = "background-color:#fdd">        return status;</span>
    }
<span style = "background-color:#dfd">    spdm_context-&gt;receiver_buffer = *msg_buf_ptr;
    *max_msg_size = spdm_context-&gt;receiver_buffer_size;</span>
    #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
    /* it return scratch buffer, because the requester need build message there.*/
    *msg_buf_ptr = spdm_context-&gt;scratch_buffer +
                   libspdm_get_scratch_buffer_large_sender_receiver_offset(spdm_context);
    *max_msg_size = libspdm_get_scratch_buffer_large_sender_receiver_capacity(spdm_context);
    #endif
<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

/**
 * Release a device receiver buffer for transport layer message.
 *
 * @param  context                       A pointer to the SPDM context.
 *
 * @retval RETURN_SUCCESS               The receiver buffer is Released.
 **/
void libspdm_release_receiver_buffer (libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{
    LIBSPDM_ASSERT(spdm_context-&gt;receiver_buffer != NULL);
    LIBSPDM_ASSERT(spdm_context-&gt;receiver_buffer_size != 0);</span>

<span style = "background-color:#dfd">    spdm_context-&gt;release_receiver_buffer (spdm_context, spdm_context-&gt;receiver_buffer);
    spdm_context-&gt;receiver_buffer = NULL;
}</span>

/**
 * Get the receiver buffer.
 *
 * @param  context                  A pointer to the SPDM context.
 * @param  receiver_buffer            Buffer address of the receiver buffer.
 * @param  receiver_buffer_size       Size of the receiver buffer.
 *
 **/
void libspdm_get_receiver_buffer (
    libspdm_context_t *spdm_context,
    void **receiver_buffer,
    size_t *receiver_buffer_size)
{
    *receiver_buffer = spdm_context-&gt;receiver_buffer;
    *receiver_buffer_size = spdm_context-&gt;receiver_buffer_size;
}

/**
 * Get the last SPDM error struct of an SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  last_spdm_error                Last SPDM error struct of an SPDM context.
 */
void libspdm_get_last_spdm_error_struct(void *spdm_context, libspdm_error_struct_t *last_spdm_error)
{
    libspdm_context_t *context;

    context = spdm_context;
    libspdm_copy_mem(last_spdm_error, sizeof(libspdm_error_struct_t),
                     &amp;context-&gt;last_spdm_error,sizeof(libspdm_error_struct_t));
}

/**
 * Set the last SPDM error struct of an SPDM context.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  last_spdm_error                Last SPDM error struct of an SPDM context.
 */
void libspdm_set_last_spdm_error_struct(void *spdm_context, libspdm_error_struct_t *last_spdm_error)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;

<span style = "background-color:#dfd">    context = spdm_context;
    libspdm_copy_mem(&amp;context-&gt;last_spdm_error, sizeof(context-&gt;last_spdm_error),</span>
                     last_spdm_error, sizeof(libspdm_error_struct_t));
<span style = "background-color:#dfd">}</span>

#if LIBSPDM_FIPS_MODE
/**
 * Initialize an libspdm_fips_selftest_context.
 *
 * @param  fips_selftest_context       A pointer to the fips_selftest_context.
 *
 * @retval RETURN_SUCCESS       context is initialized.
 * @retval RETURN_DEVICE_ERROR  context initialization failed.
 */
libspdm_return_t libspdm_init_fips_selftest_context(void *fips_selftest_context)
{
    libspdm_fips_selftest_context *context;
    LIBSPDM_ASSERT(fips_selftest_context != NULL);

    context = fips_selftest_context;

    /*No tested for every uesd algo*/
    context-&gt;tested_algo = 0;
    /*self_test reuslt is false for every uesd algo*/
    context-&gt;self_test_result = 0;

    return LIBSPDM_STATUS_SUCCESS;
}

/**
 * Return the size in bytes of the fips_selftest_context.
 *
 * @return the size in bytes of the fips_selftest_context.
 **/
size_t libspdm_get_fips_selftest_context_size(void)
{
    size_t size;

    size = sizeof(libspdm_fips_selftest_context);
    return size;
}

/**
 * import fips_selftest_context to spdm_context;
 *
 * @param[in,out]  spdm_context                A pointer to the spdm_context.
 * @param[in]      fips_selftest_context       A pointer to the fips_selftest_context.
 * @param[in]      fips_selftest_context_size  The size of fips_selftest_context.
 *
 * @retval true   import fips_selftest_context successful.
 * @retval false  spdm_context or fips_selftest_context is null.
 */
bool libspdm_import_fips_selftest_context_to_spdm_context(void *spdm_context,
                                                          void *fips_selftest_context,
                                                          size_t fips_selftest_context_size)
{
    libspdm_fips_selftest_context *libspdm_fips_selftest_context;
    libspdm_context_t *libspdm_context;

    libspdm_context = spdm_context;
    libspdm_fips_selftest_context = fips_selftest_context;

    if ((libspdm_context == NULL) || (libspdm_fips_selftest_context == NULL)) {
        return false;
    }
    if (fips_selftest_context_size != sizeof(libspdm_fips_selftest_context)) {
        return false;
    }

    libspdm_copy_mem(&amp;(libspdm_context-&gt;fips_selftest_context),
                     sizeof(libspdm_fips_selftest_context),
                     libspdm_fips_selftest_context, sizeof(libspdm_fips_selftest_context));
    return true;
}

/**
 * export fips_selftest_context from spdm_context;
 *
 * @param[in]          spdm_context                A pointer to the spdm_context.
 * @param[in,out]      fips_selftest_context       A pointer to the fips_selftest_context.
 * @param[in]          fips_selftest_context_size  The size of fips_selftest_context.
 *
 * @retval true   export fips_selftest_context successful.
 * @retval false  spdm_context or fips_selftest_context is null.
 */
bool libspdm_export_fips_selftest_context_from_spdm_context(void *spdm_context,
                                                            void *fips_selftest_context,
                                                            size_t fips_selftest_context_size)
{
    libspdm_fips_selftest_context *libspdm_fips_selftest_context;
    libspdm_context_t *libspdm_context;

    libspdm_context = spdm_context;
    libspdm_fips_selftest_context = fips_selftest_context;

    if ((libspdm_context == NULL) || (libspdm_fips_selftest_context == NULL)) {
        return false;
    }
    if (fips_selftest_context_size != sizeof(libspdm_fips_selftest_context)) {
        return false;
    }

    libspdm_copy_mem(libspdm_fips_selftest_context,
                     sizeof(libspdm_fips_selftest_context),
                     &amp;(libspdm_context-&gt;fips_selftest_context),
                     sizeof(libspdm_fips_selftest_context));
    return true;
}

#endif /* LIBSPDM_FIPS_MODE */

/**
 * Initialize an SPDM context, as well as all secured message contexts,
 * in the specified locations.
 *
 * The size in bytes of the spdm_context can be returned by
 * libspdm_get_context_size_without_secured_context.
 *
 * The size in bytes of a single secured message context can be returned by
 * libspdm_secured_message_get_context_size.
 *
 * @param  spdm_context          A pointer to the SPDM context.
 * @param  secured_contexts      An array of pointers, with each entry containing
 *                               the location of a secured message context.
 * @param  num_secured_contexts  Number of secured message contexts to initialize.
 *                               Currently, only LIBSPDM_MAX_SESSION_COUNT is supported.
 *
 * @retval RETURN_SUCCESS        Contexts are initialized.
 * @retval RETURN_DEVICE_ERROR   Context initialization failed.
 */
libspdm_return_t libspdm_init_context_with_secured_context(void *spdm_context,
                                                           void **secured_contexts,
                                                           size_t num_secured_contexts)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    size_t index;

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(spdm_context != NULL);
    LIBSPDM_ASSERT(secured_contexts != NULL);
    LIBSPDM_ASSERT(num_secured_contexts == LIBSPDM_MAX_SESSION_COUNT);</span>

<span style = "background-color:#dfd">    context = spdm_context;
    libspdm_zero_mem(context, sizeof(libspdm_context_t));
    context-&gt;version = LIBSPDM_CONTEXT_STRUCT_VERSION;
    context-&gt;transcript.message_a.max_buffer_size =</span>
        sizeof(context-&gt;transcript.message_a.buffer);
<span style = "background-color:#dfd">    context-&gt;transcript.message_d.max_buffer_size =</span>
        sizeof(context-&gt;transcript.message_d.buffer);
#if LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT
    context-&gt;transcript.message_b.max_buffer_size =
        sizeof(context-&gt;transcript.message_b.buffer);
    context-&gt;transcript.message_c.max_buffer_size =
        sizeof(context-&gt;transcript.message_c.buffer);
    context-&gt;transcript.message_mut_b.max_buffer_size =
        sizeof(context-&gt;transcript.message_mut_b.buffer);
    context-&gt;transcript.message_mut_c.max_buffer_size =
        sizeof(context-&gt;transcript.message_mut_c.buffer);
    context-&gt;transcript.message_m.max_buffer_size =
        sizeof(context-&gt;transcript.message_m.buffer);
#endif
<span style = "background-color:#dfd">    context-&gt;response_state = LIBSPDM_RESPONSE_STATE_NORMAL;
    context-&gt;local_context.version.spdm_version_count = SPDM_MAX_VERSION_COUNT;
    context-&gt;local_context.version.spdm_version[0] = SPDM_MESSAGE_VERSION_10 &lt;&lt;</span>
                                                     SPDM_VERSION_NUMBER_SHIFT_BIT;
<span style = "background-color:#dfd">    context-&gt;local_context.version.spdm_version[1] = SPDM_MESSAGE_VERSION_11 &lt;&lt;</span>
                                                     SPDM_VERSION_NUMBER_SHIFT_BIT;
<span style = "background-color:#dfd">    context-&gt;local_context.version.spdm_version[2] = SPDM_MESSAGE_VERSION_12 &lt;&lt;</span>
                                                     SPDM_VERSION_NUMBER_SHIFT_BIT;
<span style = "background-color:#dfd">    context-&gt;local_context.version.spdm_version[3] = SPDM_MESSAGE_VERSION_13 &lt;&lt;</span>
                                                     SPDM_VERSION_NUMBER_SHIFT_BIT;
<span style = "background-color:#dfd">    context-&gt;local_context.secured_message_version.spdm_version_count = 2;
    context-&gt;local_context.secured_message_version.spdm_version[0] =</span>
        SPDM_MESSAGE_VERSION_10 &lt;&lt; SPDM_VERSION_NUMBER_SHIFT_BIT;
<span style = "background-color:#dfd">    context-&gt;local_context.secured_message_version.spdm_version[1] =</span>
        SPDM_MESSAGE_VERSION_11 &lt;&lt; SPDM_VERSION_NUMBER_SHIFT_BIT;
<span style = "background-color:#dfd">    context-&gt;local_context.capability.st1 = SPDM_ST1_VALUE_US;</span>

<span style = "background-color:#dfd">    context-&gt;mut_auth_cert_chain_buffer_size = 0;</span>

<span style = "background-color:#dfd">    context-&gt;max_spdm_session_sequence_number = LIBSPDM_MAX_SPDM_SESSION_SEQUENCE_NUMBER;</span>

<span style = "background-color:#dfd">    context-&gt;latest_session_id = INVALID_SESSION_ID;
    context-&gt;last_spdm_request_session_id = INVALID_SESSION_ID;
    context-&gt;last_spdm_request_session_id_valid = false;
    context-&gt;last_spdm_request_size = 0;</span>

    /* To be updated in libspdm_register_device_buffer_func */
<span style = "background-color:#dfd">    context-&gt;local_context.capability.data_transfer_size = 0;
    context-&gt;local_context.capability.sender_data_transfer_size = 0;
    context-&gt;local_context.capability.max_spdm_msg_size = 0;</span>

<span style = "background-color:#dfd">    for (index = 0; index &lt; num_secured_contexts; index++) {
        if (secured_contexts[index] == NULL) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
        }

<span style = "background-color:#dfd">        context-&gt;session_info[index].secured_message_context = secured_contexts[index];
        libspdm_secured_message_init_context(</span>
            context-&gt;session_info[index].secured_message_context);
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

/**
 * Initialize an SPDM context, as well as secured message contexts.
 * The secured message contexts are appended to the context structure.
 *
 * The total size in bytes of the spdm_context and all secured message
 * contexts can be returned by libspdm_get_context_size().
 *
 * @param  spdm_context         A pointer to the SPDM context.
 *
 * @retval RETURN_SUCCESS       context is initialized.
 * @retval RETURN_DEVICE_ERROR  context initialization failed.
 */
libspdm_return_t libspdm_init_context(void *spdm_context)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    void *secured_context;
    void *secured_contexts[LIBSPDM_MAX_SESSION_COUNT];
    size_t secured_context_size;
    size_t index;

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(spdm_context != NULL);</span>

    /* libspdm_get_context_size() allocates space for all secured message
     * contexts. They are appended to the general SPDM context. */
<span style = "background-color:#dfd">    context = spdm_context;
    secured_context = (void *)((size_t)(context + 1));
    secured_context_size = libspdm_secured_message_get_context_size();</span>

<span style = "background-color:#dfd">    for (index = 0; index &lt; LIBSPDM_MAX_SESSION_COUNT; index++)</span>
    {
<span style = "background-color:#dfd">        secured_contexts[index] = (uint8_t *)secured_context + secured_context_size * index;
    }</span>

<span style = "background-color:#dfd">    return libspdm_init_context_with_secured_context(spdm_context,</span>
                                                     secured_contexts,
                                                     LIBSPDM_MAX_SESSION_COUNT);
<span style = "background-color:#dfd">}</span>

void libspdm_reset_context(void *spdm_context)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    size_t index;

<span style = "background-color:#dfd">    context = spdm_context;</span>

    /*Clear all info about last connection*/

    /*need clear session info to free context before algo is zeroed.*/
<span style = "background-color:#dfd">    for (index = 0; index &lt; LIBSPDM_MAX_SESSION_COUNT; index++)</span>
    {
<span style = "background-color:#dfd">        libspdm_session_info_init(context,</span>
                                  &amp;context-&gt;session_info[index],
                                  INVALID_SESSION_ID,
                                  false);
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    context-&gt;connection_info.connection_state = LIBSPDM_CONNECTION_STATE_NOT_STARTED;
    libspdm_zero_mem(&amp;context-&gt;connection_info.version, sizeof(spdm_version_number_t));
    libspdm_zero_mem(&amp;context-&gt;connection_info.capability,</span>
                     sizeof(libspdm_device_capability_t));
<span style = "background-color:#dfd">    libspdm_zero_mem(&amp;context-&gt;connection_info.algorithm, sizeof(libspdm_device_algorithm_t));
    libspdm_zero_mem(&amp;context-&gt;last_spdm_error, sizeof(libspdm_error_struct_t));
    libspdm_zero_mem(&amp;context-&gt;encap_context, sizeof(libspdm_encap_context_t));
    context-&gt;connection_info.local_used_cert_chain_buffer_size = 0;
    context-&gt;connection_info.local_used_cert_chain_buffer = NULL;
    context-&gt;connection_info.multi_key_conn_req = false;
    context-&gt;connection_info.multi_key_conn_rsp = false;</span>
#if LIBSPDM_RESPOND_IF_READY_SUPPORT
<span style = "background-color:#dfd">    context-&gt;cache_spdm_request_size = 0;</span>
#endif
<span style = "background-color:#dfd">    context-&gt;response_state = LIBSPDM_RESPONSE_STATE_NORMAL;
    context-&gt;current_token = 0;
    context-&gt;latest_session_id = INVALID_SESSION_ID;
    context-&gt;last_spdm_request_session_id = INVALID_SESSION_ID;
    context-&gt;last_spdm_request_session_id_valid = false;
    context-&gt;last_spdm_request_size = 0;
    context-&gt;mut_auth_cert_chain_buffer_size = 0;
    context-&gt;current_dhe_session_count = 0;
    context-&gt;current_psk_session_count = 0;
}</span>

/**
 * Free the memory of contexts within the SPDM context.
 * These are typically contexts whose memory has been allocated by the cryptography library.
 * This function does not free the SPDM context itself.
 *
 * @param[in]  spdm_context         A pointer to the SPDM context.
 *
 */
void libspdm_deinit_context(void *spdm_context)
{
    uint32_t session_id;
    libspdm_context_t *context;
    libspdm_session_info_t *session_info;
#if !(LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT)
    void *pubkey_context;
    bool is_requester;
    uint8_t slot_index;
#endif

    context = spdm_context;

#if !(LIBSPDM_RECORD_TRANSCRIPT_DATA_SUPPORT)
    is_requester = context-&gt;local_context.is_requester;

    for (slot_index = 0; slot_index &lt; SPDM_MAX_SLOT_COUNT; slot_index++) {
        pubkey_context = context-&gt;connection_info.peer_used_cert_chain[slot_index].
                         leaf_cert_public_key;

        if (pubkey_context != NULL) {
            if (is_requester) {
                libspdm_asym_free(
                    context-&gt;connection_info.algorithm.base_asym_algo, pubkey_context);
            } else {
                libspdm_req_asym_free(
                    context-&gt;connection_info.algorithm.req_base_asym_alg, pubkey_context);
            }

            pubkey_context = NULL;
            context-&gt;connection_info.peer_used_cert_chain[slot_index].
            leaf_cert_public_key = NULL;
        }
    }
#endif

    libspdm_reset_message_a(context);
    libspdm_reset_message_d(context);
    libspdm_reset_message_b(context);
    libspdm_reset_message_c(context);
    libspdm_reset_message_mut_b(context);
    libspdm_reset_message_mut_c(context);
    for (session_id = 0; session_id &lt; LIBSPDM_MAX_SESSION_COUNT; session_id++) {
        session_info = &amp;context-&gt;session_info[session_id];
        libspdm_reset_message_m(context, session_info);
        libspdm_reset_message_encap_d(context, session_info);
        libspdm_reset_message_k(context, session_info);
        libspdm_reset_message_f(context, session_info);
    }
}

/**
 * Return the size in bytes of the SPDM context. This includes all
 * secured message context data as well.
 *
 * For just the SPDM context size, use libspdm_get_context_size_without_secured_context.
 *
 * @return the size in bytes of the SPDM context and secured message contexts.
 **/
size_t libspdm_get_context_size(void)
<span style = "background-color:#dfd">{</span>
    size_t size;

<span style = "background-color:#dfd">    size = sizeof(libspdm_context_t) +</span>
           libspdm_secured_message_get_context_size() * LIBSPDM_MAX_SESSION_COUNT;
<span style = "background-color:#dfd">    LIBSPDM_ASSERT (size == LIBSPDM_CONTEXT_SIZE_ALL);
    return size;
}</span>

/**
 * Return the size in bytes of just the SPDM context, without secured message context.
 *
 * For the complete context size, use libspdm_get_context_size.
 *
 * @return the size in bytes of the SPDM context.
 **/
size_t libspdm_get_context_size_without_secured_context(void)
{
    size_t size;

    size = sizeof(libspdm_context_t);
    LIBSPDM_ASSERT (size == LIBSPDM_CONTEXT_SIZE_WITHOUT_SECURED_CONTEXT);
    return size;
}

/**
 * Return the SPDMversion field of the version number struct.
 *
 * @param  ver                Spdm version number struct.
 *
 * @return the SPDMversion of the version number struct.
 **/
uint8_t libspdm_get_version_from_version_number(const spdm_version_number_t ver)
<span style = "background-color:#dfd">{
    return (uint8_t)(ver &gt;&gt; SPDM_VERSION_NUMBER_SHIFT_BIT);
}</span>

/**
 * Sort SPDMversion in descending order.
 *
 * @param  spdm_context                A pointer to the SPDM context.
 * @param  ver_set                    A pointer to the version set.
 * @param  ver_num                    Version number.
 */
void libspdm_version_number_sort(spdm_version_number_t *ver_set, size_t ver_num)
<span style = "background-color:#dfd">{</span>
    size_t index;
    size_t index_sort;
    size_t index_max;
    spdm_version_number_t version;

    /* Select sort */
<span style = "background-color:#dfd">    if (ver_num &gt; 1) {
        for (index_sort = 0; index_sort &lt; ver_num; index_sort++) {
            index_max = index_sort;
            for (index = index_sort + 1; index &lt; ver_num; index++) {</span>
                /* if ver_ser[index] higher than ver_set[index_max] */
<span style = "background-color:#dfd">                if (ver_set[index] &gt; ver_set[index_max]) {
                    index_max = index;</span>
                }
<span style = "background-color:#dfd">            }</span>
            /* swap ver_ser[index_min] and ver_set[index_sort] */
<span style = "background-color:#dfd">            version = ver_set[index_sort];
            ver_set[index_sort] = ver_set[index_max];
            ver_set[index_max] = version;
        }</span>
    }
<span style = "background-color:#dfd">}</span>

/**
 * Negotiate SPDMversion for connection.
 * ver_set is the local version set of requester, res_ver_set is the version set of responder.
 *
 * @param  common_version             A pointer to store the common version.
 * @param  req_ver_set                A pointer to the requester version set.
 * @param  req_ver_num                Version number of requester.
 * @param  res_ver_set                A pointer to the responder version set.
 * @param  res_ver_num                Version number of responder.
 *
 * @retval true                       Negotiation successfully, connect version be saved to common_version.
 * @retval false                      Negotiation failed.
 */
bool libspdm_negotiate_connection_version(spdm_version_number_t *common_version,
                                          spdm_version_number_t *req_ver_set,
                                          size_t req_ver_num,
                                          const spdm_version_number_t *res_ver_set,
                                          size_t res_ver_num)
<span style = "background-color:#dfd">{</span>
    spdm_version_number_t req_version_list[LIBSPDM_MAX_VERSION_COUNT];
    spdm_version_number_t res_version_list[LIBSPDM_MAX_VERSION_COUNT];
    size_t req_index;
    size_t res_index;

<span style = "background-color:#dfd">    if (req_ver_num &gt; LIBSPDM_MAX_VERSION_COUNT || res_ver_num &gt; LIBSPDM_MAX_VERSION_COUNT) {</span>
<span style = "background-color:#fdd">        return false;</span>
    }

<span style = "background-color:#dfd">    if (req_ver_set == NULL || req_ver_num == 0 || res_ver_set == NULL || res_ver_num == 0) {</span>
<span style = "background-color:#fdd">        return false;</span>
    }

<span style = "background-color:#dfd">    libspdm_zero_mem(req_version_list, sizeof(spdm_version_number_t) * LIBSPDM_MAX_VERSION_COUNT);
    libspdm_zero_mem(res_version_list, sizeof(spdm_version_number_t) * LIBSPDM_MAX_VERSION_COUNT);</span>

<span style = "background-color:#dfd">    libspdm_copy_mem(req_version_list, sizeof(spdm_version_number_t) * LIBSPDM_MAX_VERSION_COUNT,</span>
                     req_ver_set, sizeof(spdm_version_number_t) * req_ver_num);
<span style = "background-color:#dfd">    libspdm_copy_mem(res_version_list, sizeof(spdm_version_number_t) * LIBSPDM_MAX_VERSION_COUNT,</span>
                     res_ver_set, sizeof(spdm_version_number_t) * res_ver_num);

    /* Sort SPDMversion in descending order. */
<span style = "background-color:#dfd">    libspdm_version_number_sort(req_version_list, req_ver_num);
    libspdm_version_number_sort(res_version_list, res_ver_num);</span>

    /**
     * Find highest same version and make req_index point to it.
     * If not found, return false.
     **/
<span style = "background-color:#dfd">    for (res_index = 0; res_index &lt; res_ver_num; res_index++) {
        for (req_index = 0; req_index &lt; req_ver_num; req_index++) {
            if (libspdm_get_version_from_version_number(req_version_list[req_index]) ==</span>
                libspdm_get_version_from_version_number(res_version_list[res_index])) {
<span style = "background-color:#dfd">                *common_version = req_version_list[req_index];
                return true;</span>
            }
<span style = "background-color:#dfd">        }</span>
<span style = "background-color:#fdd">    }
    return false;</span>
<span style = "background-color:#dfd">}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>