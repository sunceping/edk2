<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>libspdm_rsp_receive_send.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/**
 *  Copyright Notice:
 *  Copyright 2021-2022 DMTF. All rights reserved.
 *  License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libspdm/blob/main/LICENSE.md
 **/

#include "internal/libspdm_responder_lib.h"
#include "internal/libspdm_secured_message_lib.h"

typedef struct {
    uint8_t request_response_code;
    libspdm_get_spdm_response_func get_response_func;
} libspdm_get_response_struct_t;

/**
 * Return the GET_SPDM_RESPONSE function via request code.
 *
 * @param  request_code                  The SPDM request code.
 *
 * @return GET_SPDM_RESPONSE function according to the request code.
 **/
libspdm_get_spdm_response_func libspdm_get_response_func_via_request_code(uint8_t request_code)
<span style = "background-color:#dfd">{</span>
    size_t index;

<span style = "background-color:#dfd">    libspdm_get_response_struct_t get_response_struct[] = {</span>
        { SPDM_GET_VERSION, libspdm_get_response_version },
        { SPDM_GET_CAPABILITIES, libspdm_get_response_capabilities },
        { SPDM_NEGOTIATE_ALGORITHMS, libspdm_get_response_algorithms },

        #if LIBSPDM_ENABLE_CAPABILITY_CERT_CAP
        { SPDM_GET_DIGESTS, libspdm_get_response_digests },
        { SPDM_GET_CERTIFICATE, libspdm_get_response_certificate },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_CERT_CAP */

        #if LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP
        { SPDM_CHALLENGE, libspdm_get_response_challenge_auth },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_CHAL_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP
        { SPDM_GET_MEASUREMENTS, libspdm_get_response_measurements },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP
        { SPDM_KEY_EXCHANGE, libspdm_get_response_key_exchange },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_PSK_CAP
        { SPDM_PSK_EXCHANGE, libspdm_get_response_psk_exchange },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_PSK_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_ENCAP_CAP
        { SPDM_GET_ENCAPSULATED_REQUEST, libspdm_get_response_encapsulated_request },
        { SPDM_DELIVER_ENCAPSULATED_RESPONSE, libspdm_get_response_encapsulated_response_ack },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_ENCAP_CAP */

        #if LIBSPDM_RESPOND_IF_READY_SUPPORT
        { SPDM_RESPOND_IF_READY, libspdm_get_response_respond_if_ready },
        #endif /* LIBSPDM_RESPOND_IF_READY_SUPPORT */

        #if LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP
        { SPDM_FINISH, libspdm_get_response_finish },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_PSK_CAP
        { SPDM_PSK_FINISH, libspdm_get_response_psk_finish },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_PSK_CAP*/

        #if (LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP) || (LIBSPDM_ENABLE_CAPABILITY_PSK_CAP)
        { SPDM_END_SESSION, libspdm_get_response_end_session },
        { SPDM_HEARTBEAT, libspdm_get_response_heartbeat },
        { SPDM_KEY_UPDATE, libspdm_get_response_key_update },
        #endif /* LIBSPDM_ENABLE_CAPABILITY_KEY_EX_CAP || LIBSPDM_ENABLE_CAPABILITY_PSK_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_CSR_CAP
        { SPDM_GET_CSR, libspdm_get_response_csr },
        #endif /*LIBSPDM_ENABLE_CAPABILITY_CSR_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_SET_CERT_CAP
        { SPDM_SET_CERTIFICATE, libspdm_get_response_set_certificate },
        #endif /*LIBSPDM_ENABLE_CAPABILITY_SET_CERT_CAP*/

        #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
        { SPDM_CHUNK_GET, libspdm_get_response_chunk_get},
        { SPDM_CHUNK_SEND, libspdm_get_response_chunk_send},
        #endif /* LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP */

        #if LIBSPDM_ENABLE_VENDOR_DEFINED_MESSAGES
        { SPDM_VENDOR_DEFINED_REQUEST, libspdm_get_vendor_defined_response },
        #endif /*LIBSPDM_ENABLE_VENDOR_DEFINED_MESSAGES*/
    };

<span style = "background-color:#dfd">    for (index = 0; index &lt; sizeof(get_response_struct) / sizeof(get_response_struct[0]); index++) {
        if (request_code == get_response_struct[index].request_response_code) {
            return get_response_struct[index].get_response_func;</span>
        }
<span style = "background-color:#dfd">    }</span>
<span style = "background-color:#fdd">    return NULL;</span>
<span style = "background-color:#dfd">}</span>

/**
 * Return the GET_SPDM_RESPONSE function via last request.
 *
 * @param  spdm_context                  The SPDM context for the device.
 *
 * @return GET_SPDM_RESPONSE function according to the last request.
 **/
static libspdm_get_spdm_response_func libspdm_get_response_func_via_last_request(
    libspdm_context_t *spdm_context)
<span style = "background-color:#dfd">{</span>
    spdm_message_header_t *spdm_request;

<span style = "background-color:#dfd">    spdm_request = (void *)spdm_context-&gt;last_spdm_request;
    return libspdm_get_response_func_via_request_code(spdm_request-&gt;request_response_code);
}</span>

/**
 * Process a SPDM request from a device.
 *
 * @param  spdm_context                  The SPDM context for the device.
 * @param  session_id                    Indicate if the request is a secured message.
 *                                     If session_id is NULL, it is a normal message.
 *                                     If session_id is NOT NULL, it is a secured message.
 * @param  is_app_message                 Indicates if it is an APP message or SPDM message.
 * @param  request_size                  size in bytes of the request data buffer.
 * @param  request                      A pointer to a destination buffer to store the request.
 *                                     The caller is responsible for having
 *                                     either implicit or explicit ownership of the buffer.
 *
 * @retval RETURN_SUCCESS               The SPDM request is received successfully.
 * @retval RETURN_DEVICE_ERROR          A device error occurs when the SPDM request is received from the device.
 **/
libspdm_return_t libspdm_process_request(void *spdm_context, uint32_t **session_id,
                                         bool *is_app_message,
                                         size_t request_size, void *request)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    void *temp_session_context;
    libspdm_return_t status;
    libspdm_session_info_t *session_info;
    uint32_t *message_session_id;
    uint8_t *decoded_message_ptr;
    size_t decoded_message_size;
    uint8_t *backup_decoded_message_ptr;
    size_t backup_decoded_message_size;
    bool result;
    bool reset_key_update;

<span style = "background-color:#dfd">    context = spdm_context;</span>
    size_t transport_header_size;
    uint8_t *scratch_buffer;
    size_t scratch_buffer_size;

<span style = "background-color:#dfd">    if (request == NULL) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
    }
<span style = "background-color:#dfd">    if (request_size == 0) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
    }

<span style = "background-color:#dfd">    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "SpdmReceiveRequest[.] ...\n"));</span>

<span style = "background-color:#dfd">    message_session_id = NULL;
    context-&gt;last_spdm_request_session_id_valid = false;
    context-&gt;last_spdm_request_size =</span>
        libspdm_get_scratch_buffer_last_spdm_request_capacity(context);

    /* always use scratch buffer to response.
     * if it is secured message, this scratch buffer will be used.
     * if it is normal message, the response ptr will point to receiver buffer. */
<span style = "background-color:#dfd">    transport_header_size = context-&gt;local_context.capability.transport_header_size;
    libspdm_get_scratch_buffer (context, (void **)&amp;scratch_buffer, &amp;scratch_buffer_size);</span>
    #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
    decoded_message_ptr = scratch_buffer +
                          libspdm_get_scratch_buffer_secure_message_offset(context) +
                          transport_header_size;
    decoded_message_size = libspdm_get_scratch_buffer_secure_message_capacity(context) -
                           transport_header_size;
    #else
<span style = "background-color:#dfd">    decoded_message_ptr = scratch_buffer + transport_header_size;
    decoded_message_size = scratch_buffer_size - transport_header_size;</span>
    #endif /* LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP */

<span style = "background-color:#dfd">    backup_decoded_message_ptr = decoded_message_ptr;
    backup_decoded_message_size = decoded_message_size;</span>

<span style = "background-color:#dfd">    status = context-&gt;transport_decode_message(</span>
        context, &amp;message_session_id, is_app_message, true,
        request_size, request, &amp;decoded_message_size,
        (void **)&amp;decoded_message_ptr);

<span style = "background-color:#dfd">    reset_key_update = false;
    temp_session_context = NULL;</span>

<span style = "background-color:#dfd">    if (status == LIBSPDM_STATUS_SESSION_TRY_DISCARD_KEY_UPDATE) {</span>
        /* Failed to decode, but have backup keys. Try rolling back before aborting.
         * message_session_id must be valid for us to have attempted decryption. */
<span style = "background-color:#fdd">        if (message_session_id == NULL) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
        }
<span style = "background-color:#fdd">        temp_session_context = libspdm_get_secured_message_context_via_session_id(</span>
            context, *message_session_id);
<span style = "background-color:#fdd">        if (temp_session_context == NULL) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
        }

<span style = "background-color:#fdd">        result = libspdm_activate_update_session_data_key(</span>
            temp_session_context, LIBSPDM_KEY_UPDATE_ACTION_REQUESTER, false);
<span style = "background-color:#fdd">        if (!result) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
        }
<span style = "background-color:#fdd">        libspdm_trigger_key_update_callback(</span>
            context, *message_session_id,
            LIBSPDM_KEY_UPDATE_OPERATION_DISCARD_UPDATE,
            LIBSPDM_KEY_UPDATE_ACTION_REQUESTER);

        /* Retry decoding message with backup Requester key.
         * Must reset some of the parameters in case they were modified */
<span style = "background-color:#fdd">        message_session_id = NULL;
        decoded_message_ptr = backup_decoded_message_ptr;
        decoded_message_size = backup_decoded_message_size;
        status = context-&gt;transport_decode_message(</span>
            context, &amp;message_session_id, is_app_message, true,
            request_size, request, &amp;decoded_message_size,
            (void **)&amp;decoded_message_ptr);

<span style = "background-color:#fdd">        reset_key_update = true;</span>
    }

<span style = "background-color:#dfd">    if (LIBSPDM_STATUS_IS_ERROR(status)) {</span>
<span style = "background-color:#fdd">        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "transport_decode_message : %p\n", status));
        if (context-&gt;last_spdm_error.error_code != 0) {</span>

            /* If the SPDM error code is Non-Zero, that means we need send the error message back to requester.
             * In this case, we need return SUCCESS and let caller invoke libspdm_build_response() to send an ERROR message.*/

<span style = "background-color:#fdd">            *session_id = &amp;context-&gt;last_spdm_error.session_id;
            *is_app_message = false;
            return LIBSPDM_STATUS_SUCCESS;</span>
        }
<span style = "background-color:#fdd">        return status;</span>
    }

    /* Handle special case for bi-directional communication:
     * If the Requester returns RESPONSE_NOT_READY error to KEY_UPDATE, the Responder needs
     * to activate backup key to parse the error. Then later the Requester will return SUCCESS,
     * the Responder needs new key. So we need to restore the environment by
     * libspdm_create_update_session_data_key() again.*/
<span style = "background-color:#dfd">    if (reset_key_update) {</span>
        /* temp_session_context and message_session_id must necessarily
         * be valid for us to reach here. */
<span style = "background-color:#fdd">        if (temp_session_context == NULL || message_session_id == NULL) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
        }
<span style = "background-color:#fdd">        result = libspdm_create_update_session_data_key(</span>
            temp_session_context, LIBSPDM_KEY_UPDATE_ACTION_REQUESTER);
<span style = "background-color:#fdd">        if (!result) {
            return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
        }
<span style = "background-color:#fdd">        libspdm_trigger_key_update_callback(</span>
            context, *message_session_id,
            LIBSPDM_KEY_UPDATE_OPERATION_CREATE_UPDATE,
            LIBSPDM_KEY_UPDATE_ACTION_REQUESTER);
    }

<span style = "background-color:#dfd">    context-&gt;last_spdm_request_size = decoded_message_size;
    libspdm_copy_mem (context-&gt;last_spdm_request,</span>
                      libspdm_get_scratch_buffer_last_spdm_request_capacity(context),
                      decoded_message_ptr,
                      decoded_message_size);

<span style = "background-color:#dfd">    if (!(*is_app_message)) {</span>
        /* Check for minimal SPDM message size. */
<span style = "background-color:#dfd">        if (context-&gt;last_spdm_request_size &lt; sizeof(spdm_message_header_t)) {</span>
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
        }
    }

<span style = "background-color:#dfd">    *session_id = message_session_id;</span>

<span style = "background-color:#dfd">    if (message_session_id != NULL) {</span>
<span style = "background-color:#fdd">        session_info = libspdm_get_session_info_via_session_id(context, *message_session_id);
        if (session_info == NULL) {
            return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
        }
<span style = "background-color:#fdd">        context-&gt;last_spdm_request_session_id = *message_session_id;
        context-&gt;last_spdm_request_session_id_valid = true;</span>
    }

<span style = "background-color:#dfd">    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "SpdmReceiveRequest[%x] msg %s(0x%x), size (0x%x): \n",</span>
                   (message_session_id != NULL) ? *message_session_id : 0,
                   libspdm_get_code_str(((spdm_message_header_t *)context-&gt;last_spdm_request)-&gt;
                                        request_response_code),
                   ((spdm_message_header_t *)context-&gt;last_spdm_request)-&gt;request_response_code,
<span style = "background-color:#dfd">                   context-&gt;last_spdm_request_size));
    LIBSPDM_INTERNAL_DUMP_HEX((uint8_t *)context-&gt;last_spdm_request,</span>
                              context-&gt;last_spdm_request_size);

<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

/**
 * Notify the session state to a session APP.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  session_id                    The session_id of a session.
 * @param  session_state                 The state of a session.
 **/
static void libspdm_trigger_session_state_callback(libspdm_context_t *spdm_context,
                                                   uint32_t session_id,
                                                   libspdm_session_state_t session_state)
<span style = "background-color:#fdd">{
    if (spdm_context-&gt;spdm_session_state_callback != NULL) {</span>
        ((libspdm_session_state_callback_func)
<span style = "background-color:#fdd">         spdm_context-&gt;spdm_session_state_callback)(spdm_context, session_id, session_state);</span>
    }
<span style = "background-color:#fdd">}</span>

/**
 * Set session_state to an SPDM secured message context and trigger callback.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  session_id                    Indicate the SPDM session ID.
 * @param  session_state                 Indicate the SPDM session state.
 */
void libspdm_set_session_state(libspdm_context_t *spdm_context,
                               uint32_t session_id,
                               libspdm_session_state_t session_state)
<span style = "background-color:#fdd">{</span>
    libspdm_session_info_t *session_info;
    libspdm_session_state_t old_session_state;

<span style = "background-color:#fdd">    session_info = libspdm_get_session_info_via_session_id(spdm_context, session_id);
    if (session_info == NULL) {
        LIBSPDM_ASSERT(false);
        return;</span>
    }

<span style = "background-color:#fdd">    old_session_state = libspdm_secured_message_get_session_state(</span>
        session_info-&gt;secured_message_context);
<span style = "background-color:#fdd">    if (old_session_state != session_state) {
        libspdm_secured_message_set_session_state(</span>
            session_info-&gt;secured_message_context, session_state);
<span style = "background-color:#fdd">        libspdm_trigger_session_state_callback(</span>
            spdm_context, session_info-&gt;session_id, session_state);
    }
<span style = "background-color:#fdd">}</span>

/**
 * Notify the connection state to an SPDM context register.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  connection_state              Indicate the SPDM connection state.
 **/
static void libspdm_trigger_connection_state_callback(libspdm_context_t *spdm_context,
                                                      const libspdm_connection_state_t
                                                      connection_state)
<span style = "background-color:#dfd">{
    if (spdm_context-&gt;spdm_connection_state_callback != NULL) {</span>
        ((libspdm_connection_state_callback_func)
<span style = "background-color:#fdd">         spdm_context-&gt;spdm_connection_state_callback)(spdm_context, connection_state);</span>
    }
<span style = "background-color:#dfd">}</span>

/**
 * Set connection_state to an SPDM context and trigger callback.
 *
 * @param  spdm_context                  A pointer to the SPDM context.
 * @param  connection_state              Indicate the SPDM connection state.
 */
void libspdm_set_connection_state(libspdm_context_t *spdm_context,
                                  libspdm_connection_state_t connection_state)
<span style = "background-color:#dfd">{
    if (spdm_context-&gt;connection_info.connection_state != connection_state) {
        spdm_context-&gt;connection_info.connection_state = connection_state;
        libspdm_trigger_connection_state_callback(spdm_context, connection_state);</span>
    }
<span style = "background-color:#dfd">}</span>

void libspdm_trigger_key_update_callback(void *spdm_context, uint32_t session_id,
                                         libspdm_key_update_operation_t key_update_op,
                                         libspdm_key_update_action_t key_update_action)
<span style = "background-color:#fdd">{</span>
    libspdm_context_t *context;

<span style = "background-color:#fdd">    context = spdm_context;
    if (context-&gt;spdm_key_update_callback != NULL) {</span>
        ((libspdm_key_update_callback_func)
<span style = "background-color:#fdd">         context-&gt;spdm_key_update_callback)(context, session_id, key_update_op,</span>
                                            key_update_action);
    }
<span style = "background-color:#fdd">}</span>

/**
 * Build a SPDM response to a device.
 *
 * @param  spdm_context                  The SPDM context for the device.
 * @param  session_id                    Indicate if the response is a secured message.
 *                                     If session_id is NULL, it is a normal message.
 *                                     If session_id is NOT NULL, it is a secured message.
 * @param  is_app_message                 Indicates if it is an APP message or SPDM message.
 * @param  response_size                 size in bytes of the response data buffer.
 * @param  response                     A pointer to a destination buffer to store the response.
 *                                     The caller is responsible for having
 *                                     either implicit or explicit ownership of the buffer.
 *
 * @retval RETURN_SUCCESS               The SPDM response is sent successfully.
 * @retval RETURN_DEVICE_ERROR          A device error occurs when the SPDM response is sent to the device.
 * @retval RETURN_UNSUPPORTED           Just ignore this message: return UNSUPPORTED and clear response_size.
 *                                      Continue the dispatch without send response.
 **/
libspdm_return_t libspdm_build_response(void *spdm_context, const uint32_t *session_id,
                                        bool is_app_message,
                                        size_t *response_size,
                                        void **response)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *context;
    uint8_t *my_response;
    size_t my_response_size;
    libspdm_return_t status;
    libspdm_get_spdm_response_func get_response_func;
    libspdm_session_info_t *session_info;
    spdm_message_header_t *spdm_request;
    spdm_message_header_t *spdm_response;
    size_t transport_header_size;
    uint8_t *scratch_buffer;
    size_t scratch_buffer_size;
    uint8_t request_response_code;
    uint32_t actual_size;

    #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP
    bool result;
    #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */

    #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
    uint8_t *large_buffer;
    size_t large_buffer_size;
    libspdm_chunk_info_t* get_info;
    spdm_chunk_response_response_t *chunk_rsp;
    uint8_t *chunk_ptr;
    #endif /* LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP */

<span style = "background-color:#dfd">    context = spdm_context;
    status = LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>

    /* For secure message, setup my_response to scratch buffer
     * For non-secure message, setup my_response to sender buffer*/
<span style = "background-color:#dfd">    transport_header_size = context-&gt;local_context.capability.transport_header_size;
    if (session_id != NULL) {</span>
<span style = "background-color:#fdd">        libspdm_get_scratch_buffer (context, (void **)&amp;scratch_buffer, &amp;scratch_buffer_size);</span>
        #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
        my_response = scratch_buffer + libspdm_get_scratch_buffer_secure_message_offset(context) +
                      transport_header_size;
        my_response_size = libspdm_get_scratch_buffer_secure_message_capacity(context) -
                           transport_header_size -
                           context-&gt;local_context.capability.transport_tail_size;
        #else
<span style = "background-color:#fdd">        my_response = scratch_buffer + transport_header_size;
        my_response_size = scratch_buffer_size - transport_header_size -</span>
                           context-&gt;local_context.capability.transport_tail_size;
        #endif /* LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP */
<span style = "background-color:#fdd">    } else {</span>
<span style = "background-color:#dfd">        my_response = (uint8_t *)*response + transport_header_size;
        my_response_size = *response_size - transport_header_size -</span>
                           context-&gt;local_context.capability.transport_tail_size;
    }
<span style = "background-color:#dfd">    libspdm_zero_mem(my_response, my_response_size);</span>

<span style = "background-color:#dfd">    spdm_response = (void *)my_response;</span>

<span style = "background-color:#dfd">    if (context-&gt;last_spdm_error.error_code != 0) {</span>

        /* Error in libspdm_process_request(), and we need send error message directly.*/

<span style = "background-color:#fdd">        switch (context-&gt;last_spdm_error.error_code) {</span>
        case SPDM_ERROR_CODE_DECRYPT_ERROR:
            /* session ID is valid. Use it to encrypt the error message.*/
            if((context-&gt;handle_error_return_policy &amp;
<span style = "background-color:#fdd">                LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {
                status = libspdm_generate_error_response(</span>
                    context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,
                    &amp;my_response_size, my_response);
<span style = "background-color:#fdd">            } else {</span>
                /**
                 * just ignore this message
                 * return UNSUPPORTED and clear response_size to continue the dispatch without send response
                 **/
<span style = "background-color:#fdd">                *response_size = 0;
                status = LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
            }
<span style = "background-color:#fdd">            break;</span>
        case SPDM_ERROR_CODE_INVALID_SESSION:
            /**
             * don't use session ID, because we dont know which right session ID should be used.
             * just ignore this message
             * return UNSUPPORTED and clear response_size to continue the dispatch without send response
             **/
<span style = "background-color:#fdd">            *response_size = 0;
            status = LIBSPDM_STATUS_UNSUPPORTED_CAP;
            break;</span>
        default:
<span style = "background-color:#fdd">            LIBSPDM_ASSERT(false);
            status = LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
        }

<span style = "background-color:#fdd">        if (LIBSPDM_STATUS_IS_ERROR(status)) {
            if ((session_id != NULL) &amp;&amp;</span>
                (context-&gt;last_spdm_error.error_code == SPDM_ERROR_CODE_DECRYPT_ERROR)) {
<span style = "background-color:#fdd">                libspdm_free_session_id(context, *session_id);</span>
            }
<span style = "background-color:#fdd">            return status;</span>
        }

<span style = "background-color:#fdd">        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "SpdmSendResponse[%x]: msg %s(0x%x), size (0x%x): \n",</span>
                       (session_id != NULL) ? *session_id : 0,
                       libspdm_get_code_str(spdm_response-&gt;request_response_code),
                       spdm_response-&gt;request_response_code,
<span style = "background-color:#fdd">                       my_response_size));
        LIBSPDM_INTERNAL_DUMP_HEX(my_response, my_response_size);</span>

<span style = "background-color:#fdd">        status = context-&gt;transport_encode_message(</span>
            context, session_id, false, false,
            my_response_size, my_response, response_size, response);
<span style = "background-color:#fdd">        if (LIBSPDM_STATUS_IS_ERROR(status)) {
            if ((session_id != NULL) &amp;&amp;</span>
                ((status == LIBSPDM_STATUS_SEQUENCE_NUMBER_OVERFLOW) ||
                 (status == LIBSPDM_STATUS_CRYPTO_ERROR))) {
<span style = "background-color:#fdd">                libspdm_free_session_id(context, *session_id);</span>
            }
<span style = "background-color:#fdd">            LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "transport_encode_message : %p\n", status));
            return status;</span>
        }

<span style = "background-color:#fdd">        if ((session_id != NULL) &amp;&amp;</span>
            (context-&gt;last_spdm_error.error_code == SPDM_ERROR_CODE_DECRYPT_ERROR)) {
<span style = "background-color:#fdd">            libspdm_free_session_id(context, *session_id);</span>
        }

<span style = "background-color:#fdd">        libspdm_zero_mem(&amp;context-&gt;last_spdm_error, sizeof(context-&gt;last_spdm_error));
        return LIBSPDM_STATUS_SUCCESS;</span>
    }

<span style = "background-color:#dfd">    if (session_id != NULL) {</span>
<span style = "background-color:#fdd">        session_info = libspdm_get_session_info_via_session_id(context, *session_id);
        if (session_info == NULL) {
            LIBSPDM_ASSERT(false);
            return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
        }
    }

<span style = "background-color:#dfd">    if (*response == NULL) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
    }
<span style = "background-color:#dfd">    if (response_size == NULL) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
    }
<span style = "background-color:#dfd">    if (*response_size == 0) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_PARAMETER;</span>
    }

<span style = "background-color:#dfd">    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "SpdmSendResponse[%x] ...\n",
                   (session_id != NULL) ? *session_id : 0));</span>

<span style = "background-color:#dfd">    spdm_request = (void *)context-&gt;last_spdm_request;
    if (context-&gt;last_spdm_request_size == 0) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
    }

<span style = "background-color:#dfd">    get_response_func = NULL;
    if (!is_app_message) {
        get_response_func = libspdm_get_response_func_via_last_request(context);</span>

        #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
        /* If responder is expecting chunk_get or chunk_send requests
         * and gets other requests instead, drop out of chunking mode */
        if (context-&gt;chunk_context.get.chunk_in_use
            &amp;&amp; get_response_func != libspdm_get_response_chunk_get) {

            context-&gt;chunk_context.get.chunk_in_use = false;
            context-&gt;chunk_context.get.chunk_handle++; /* implicit wrap - around to 0. */
            context-&gt;chunk_context.get.chunk_seq_no = 0;

            context-&gt;chunk_context.get.large_message = NULL;
            context-&gt;chunk_context.get.large_message_size = 0;
            context-&gt;chunk_context.get.chunk_bytes_transferred = 0;
        }
        if (context-&gt;chunk_context.send.chunk_in_use
            &amp;&amp; get_response_func != libspdm_get_response_chunk_send) {

            context-&gt;chunk_context.send.chunk_in_use = false;
            context-&gt;chunk_context.send.chunk_handle = 0;
            context-&gt;chunk_context.send.chunk_seq_no = 0;

            context-&gt;chunk_context.send.large_message = NULL;
            context-&gt;chunk_context.send.large_message_size = 0;
            context-&gt;chunk_context.send.chunk_bytes_transferred = 0;
        }
        #endif /* LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP */

<span style = "background-color:#dfd">        if (get_response_func != NULL) {
            status = get_response_func(</span>
                context,
                context-&gt;last_spdm_request_size,
                context-&gt;last_spdm_request,
                &amp;my_response_size, my_response);
        }
    }
<span style = "background-color:#dfd">    if (is_app_message || (get_response_func == NULL)) {</span>
<span style = "background-color:#fdd">        if (context-&gt;get_response_func != NULL) {
            status = ((libspdm_get_response_func) context-&gt;get_response_func)(</span>
                context, session_id, is_app_message,
                context-&gt;last_spdm_request_size,
                context-&gt;last_spdm_request,
                &amp;my_response_size, my_response);
<span style = "background-color:#fdd">        } else {
            status = LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
        }
    }

<span style = "background-color:#dfd">    if (status == LIBSPDM_STATUS_SUCCESS) {
        LIBSPDM_ASSERT (my_response_size &lt;= context-&gt;local_context.capability.max_spdm_msg_size);</span>
        /* large SPDM message is the SPDM message whose size is greater than the DataTransferSize of the receiving
         * SPDM endpoint or greater than the transmit buffer size of the sending SPDM endpoint */
<span style = "background-color:#dfd">        if ((context-&gt;connection_info.capability.max_spdm_msg_size != 0) &amp;&amp;</span>
            (my_response_size &gt; context-&gt;connection_info.capability.max_spdm_msg_size)) {
<span style = "background-color:#fdd">            LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR, "my_response_size &gt; req max_spdm_msg_size\n"));
            actual_size = (uint32_t)my_response_size;
            status = libspdm_generate_extended_error_response(context,</span>
                                                              SPDM_ERROR_CODE_RESPONSE_TOO_LARGE,
                                                              0,
                                                              sizeof(uint32_t),
                                                              (uint8_t *)&amp;actual_size,
                                                              &amp;my_response_size, my_response);
<span style = "background-color:#fdd">        } else if ((((context-&gt;connection_info.capability.data_transfer_size != 0) &amp;&amp;</span>
                     (my_response_size &gt; context-&gt;connection_info.capability.data_transfer_size)) ||
                    ((context-&gt;local_context.capability.sender_data_transfer_size != 0) &amp;&amp;
                     (my_response_size &gt;
<span style = "background-color:#dfd">                      context-&gt;local_context.capability.sender_data_transfer_size))) &amp;&amp;</span>
                   libspdm_is_capabilities_flag_supported(
                       context, false, SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CHUNK_CAP,
                       SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHUNK_CAP)) {
            #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP

            get_info = &amp;context-&gt;chunk_context.get;

            /* Saving multiple large responses is not an expected use case.
             * Therefore, if the requester did not perform chunk_get requests for
             * previous large responses, they will be lost. */
            if (get_info-&gt;chunk_in_use) {
                LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR,
                               "Warning: Overwriting previous unrequested chunk_get info.\n"));
            }

            libspdm_get_scratch_buffer(context, (void **)&amp;scratch_buffer, &amp;scratch_buffer_size);

            /* The first section of the scratch
             * buffer may be used for other purposes. Use only after that section. */

            large_buffer = (uint8_t*)scratch_buffer +
                           libspdm_get_scratch_buffer_large_message_offset(spdm_context);
            large_buffer_size = libspdm_get_scratch_buffer_large_message_capacity(spdm_context);

            get_info-&gt;chunk_in_use = true;
            /* Increment chunk_handle here as opposed to end of chunk_get handler
             * in case requester never issues chunk_get. */
            get_info-&gt;chunk_handle++;
            get_info-&gt;chunk_seq_no = 0;
            get_info-&gt;chunk_bytes_transferred = 0;

            libspdm_zero_mem(large_buffer, large_buffer_size);

            /* It's possible that the large response that was to be sent to the requester was
             * a CHUNK_SEND_ACK + non-chunk response. In this case, to prevent chunking within
             * chunking, only send back the actual response, by saving only non-chunk portion
             * in the scratch buffer, used to respond to the next CHUNK_GET request. */
            if (((spdm_message_header_t*) my_response)
                -&gt;request_response_code == SPDM_CHUNK_SEND_ACK) {
                libspdm_copy_mem(large_buffer, large_buffer_size,
                                 my_response + sizeof(spdm_chunk_send_ack_response_t),
                                 my_response_size - sizeof(spdm_chunk_send_ack_response_t));

                get_info-&gt;large_message = large_buffer;
                get_info-&gt;large_message_size =
                    my_response_size - sizeof(spdm_chunk_send_ack_response_t);
            } else {
                libspdm_copy_mem(large_buffer, large_buffer_size,
                                 my_response, my_response_size);

                get_info-&gt;large_message = large_buffer;
                get_info-&gt;large_message_size = my_response_size;
            }

            status = libspdm_generate_extended_error_response(context,
                                                              SPDM_ERROR_CODE_LARGE_RESPONSE, 0,
                                                              sizeof(uint8_t),
                                                              &amp;get_info-&gt;chunk_handle,
                                                              &amp;my_response_size, my_response);
            #else
<span style = "background-color:#fdd">            LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR,
                           "Warning: Could not save chunk. Scratch buffer too small.\n"));</span>

<span style = "background-color:#fdd">            status = libspdm_generate_extended_error_response(context,</span>
                                                              SPDM_ERROR_CODE_LARGE_RESPONSE,
                                                              0, 0, NULL,
                                                              &amp;my_response_size, my_response);
            #endif /* LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP */

<span style = "background-color:#fdd">            if (LIBSPDM_STATUS_IS_ERROR(status)) {
                return status;</span>
            }
        }
    }

    /* if return the status: Responder drop the response
     * just ignore this message
     * return UNSUPPORTED and clear response_size to continue the dispatch without send response.*/
<span style = "background-color:#dfd">    if((my_response_size == 0) &amp;&amp; (status == LIBSPDM_STATUS_UNSUPPORTED_CAP)) {</span>
<span style = "background-color:#fdd">        *response_size = 0;
        return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
    }

<span style = "background-color:#dfd">    if (LIBSPDM_STATUS_IS_ERROR(status)) {</span>
<span style = "background-color:#fdd">        status = libspdm_generate_error_response(</span>
            context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,
            spdm_request-&gt;request_response_code, &amp;my_response_size,
            my_response);
<span style = "background-color:#fdd">        if (LIBSPDM_STATUS_IS_ERROR(status)) {
            return status;</span>
        }
    }

<span style = "background-color:#dfd">    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "SpdmSendResponse[%x]: msg %s(0x%x), size (0x%x): \n",</span>
                   (session_id != NULL) ? *session_id : 0,
                   libspdm_get_code_str(spdm_response-&gt;request_response_code),
                   spdm_response-&gt;request_response_code,
<span style = "background-color:#dfd">                   my_response_size));
    LIBSPDM_INTERNAL_DUMP_HEX(my_response, my_response_size);</span>

<span style = "background-color:#dfd">    status = context-&gt;transport_encode_message(</span>
        context, session_id, is_app_message, false,
        my_response_size, my_response, response_size, response);
<span style = "background-color:#dfd">    if (LIBSPDM_STATUS_IS_ERROR(status)) {</span>
<span style = "background-color:#fdd">        if ((session_id != NULL) &amp;&amp;</span>
            ((status == LIBSPDM_STATUS_SEQUENCE_NUMBER_OVERFLOW) ||
             (status == LIBSPDM_STATUS_CRYPTO_ERROR))) {
<span style = "background-color:#fdd">            libspdm_free_session_id(context, *session_id);</span>
        }
<span style = "background-color:#fdd">        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, "transport_encode_message : %p\n", status));
        return status;</span>
    }

<span style = "background-color:#dfd">    request_response_code = spdm_response-&gt;request_response_code;</span>
    #if LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP
    switch (request_response_code) {
    case SPDM_CHUNK_SEND_ACK:
        if (my_response_size &gt; sizeof(spdm_chunk_send_ack_response_t)) {
            request_response_code =
                ((spdm_message_header_t*)(my_response + sizeof(spdm_chunk_send_ack_response_t)))
                -&gt;request_response_code;
        }
        break;
    case SPDM_CHUNK_RESPONSE:
        chunk_rsp = (spdm_chunk_response_response_t *)my_response;
        chunk_ptr = (uint8_t*) (((uint32_t*) (chunk_rsp + 1)) + 1);
        if (chunk_rsp-&gt;chunk_seq_no == 0) {
            request_response_code = ((spdm_message_header_t*)chunk_ptr)-&gt;request_response_code;
        }
        break;
    default:
        break;
    }
    #endif /* LIBSPDM_ENABLE_CAPABILITY_CHUNK_CAP */

<span style = "background-color:#dfd">    if (session_id != NULL) {</span>
<span style = "background-color:#fdd">        switch (request_response_code) {</span>
        case SPDM_FINISH_RSP:
<span style = "background-color:#fdd">            if (!libspdm_is_capabilities_flag_supported(</span>
                    context, false,
                    SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
                    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
<span style = "background-color:#fdd">                libspdm_set_session_state(</span>
                    context, *session_id,
                    LIBSPDM_SESSION_STATE_ESTABLISHED);
            }
<span style = "background-color:#fdd">            break;</span>
        case SPDM_PSK_FINISH_RSP:
<span style = "background-color:#fdd">            libspdm_set_session_state(context, *session_id,</span>
                                      LIBSPDM_SESSION_STATE_ESTABLISHED);
<span style = "background-color:#fdd">            break;</span>
        case SPDM_END_SESSION_ACK:
<span style = "background-color:#fdd">            libspdm_set_session_state(context, *session_id,</span>
                                      LIBSPDM_SESSION_STATE_NOT_STARTED);
            #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP
            if (libspdm_is_capabilities_flag_supported(
                    context, false,
                    SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,
                    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {
                result = libspdm_stop_watchdog(*session_id);
                if (!result) {
                    LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR, "libspdm_stop_watchdog error\n"));
                    /* No need to return error for internal watchdog error. */
                }
            }
            #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */
<span style = "background-color:#fdd">            libspdm_free_session_id(context, *session_id);</span>
            break;
        default:
            #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP
            if (libspdm_is_capabilities_flag_supported(
                    context, false,
                    SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,
                    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {
                /* reset watchdog in any session messages. */
                result = libspdm_reset_watchdog(*session_id);
                if (!result) {
                    LIBSPDM_DEBUG((LIBSPDM_DEBUG_ERROR, "libspdm_reset_watchdog error\n"));
                    /* No need to return error for internal watchdog error. */
                }
            }
            #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */
            break;
        }
<span style = "background-color:#fdd">    } else {</span>
<span style = "background-color:#dfd">        switch (request_response_code) {</span>
        case SPDM_FINISH_RSP:
<span style = "background-color:#fdd">            if (libspdm_is_capabilities_flag_supported(</span>
                    context, false,
                    SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,
                    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {
<span style = "background-color:#fdd">                libspdm_set_session_state(</span>
                    context,
                    context-&gt;latest_session_id,
                    LIBSPDM_SESSION_STATE_ESTABLISHED);
            }
            break;
        default:
            /* No session state update needed */
            break;
        }
    }

<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

void libspdm_register_get_response_func(void *context, libspdm_get_response_func get_response_func)
<span style = "background-color:#dfd">{</span>
    libspdm_context_t *spdm_context;

<span style = "background-color:#dfd">    spdm_context = context;
    spdm_context-&gt;get_response_func = (void *)get_response_func;
}</span>

void libspdm_register_session_state_callback_func(
    void *spdm_context,
    libspdm_session_state_callback_func spdm_session_state_callback)
{
    libspdm_context_t *context;

    LIBSPDM_ASSERT(spdm_context != NULL);

    context = spdm_context;

    context-&gt;spdm_session_state_callback = (void *)spdm_session_state_callback;
}

void libspdm_register_connection_state_callback_func(
    void *spdm_context,
    libspdm_connection_state_callback_func spdm_connection_state_callback)
{
    libspdm_context_t *context;

    LIBSPDM_ASSERT(spdm_context != NULL);

    context = spdm_context;
    context-&gt;spdm_connection_state_callback = (void *)spdm_connection_state_callback;
}

void libspdm_register_key_update_callback_func(
    void *spdm_context, libspdm_key_update_callback_func spdm_key_update_callback)
{
    libspdm_context_t *context;

    LIBSPDM_ASSERT(spdm_context != NULL);

    context = spdm_context;
    context-&gt;spdm_key_update_callback = (void *)spdm_key_update_callback;
}

#if (LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP) &amp;&amp; (LIBSPDM_ENABLE_CAPABILITY_ENCAP_CAP) &amp;&amp; \
    (LIBSPDM_SEND_GET_CERTIFICATE_SUPPORT)
void libspdm_register_cert_chain_buffer(
    void *spdm_context, void *cert_chain_buffer, size_t cert_chain_buffer_max_size)
{
    libspdm_context_t *context;

    LIBSPDM_ASSERT(spdm_context != NULL);

    context = spdm_context;
    context-&gt;mut_auth_cert_chain_buffer = cert_chain_buffer;
    context-&gt;mut_auth_cert_chain_buffer_max_size = cert_chain_buffer_max_size;
    context-&gt;mut_auth_cert_chain_buffer_size = 0;
}
#endif</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>