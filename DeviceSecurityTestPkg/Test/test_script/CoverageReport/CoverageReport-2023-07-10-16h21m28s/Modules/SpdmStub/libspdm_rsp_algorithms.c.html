<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>libspdm_rsp_algorithms.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/**
 *  Copyright Notice:
 *  Copyright 2021-2022 DMTF. All rights reserved.
 *  License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libspdm/blob/main/LICENSE.md
 **/

#include "internal/libspdm_responder_lib.h"

/* current version libspdm does not support any ext algo.
 * the responder will ignore the ext algo in request.
 * the responder will not build ext algo in response.*/
#pragma pack(1)
typedef struct {
    spdm_message_header_t header;
    uint16_t length;
    uint8_t measurement_specification_sel;
    uint8_t other_params_selection;
    uint32_t measurement_hash_algo;
    uint32_t base_asym_sel;
    uint32_t base_hash_sel;
    uint8_t reserved2[12];
    uint8_t ext_asym_sel_count;
    uint8_t ext_hash_sel_count;
    uint16_t reserved3;
    spdm_negotiate_algorithms_common_struct_table_t struct_table[4];
} libspdm_algorithms_response_mine_t;
#pragma pack()

/**
 * Select the preferred supported algorithm according to the priority_table.
 *
 * @param  priority_table        The priority table.
 * @param  priority_table_count  The count of the priority table entry.
 * @param  local_algo            Local supported algorithm.
 * @param  peer_algo             Peer supported algorithm.
 *
 * @return   Preferred supported algorithm
 **/
static uint32_t libspdm_prioritize_algorithm(const uint32_t *priority_table,
                                             size_t priority_table_count,
                                             uint32_t local_algo, uint32_t peer_algo)
<span style = "background-color:#dfd">{</span>
    uint32_t common_algo;
    size_t index;

<span style = "background-color:#dfd">    common_algo = (local_algo &amp; peer_algo);
    for (index = 0; index &lt; priority_table_count; index++) {
        if ((common_algo &amp; priority_table[index]) != 0) {
            return priority_table[index];</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return 0;
}</span>

libspdm_return_t libspdm_get_response_algorithms(libspdm_context_t *spdm_context,
                                                 size_t request_size,
                                                 const void *request,
                                                 size_t *response_size,
                                                 void *response)
<span style = "background-color:#dfd">{</span>
    const spdm_negotiate_algorithms_request_t *spdm_request;
    size_t spdm_request_size;
    libspdm_algorithms_response_mine_t *spdm_response;
    spdm_negotiate_algorithms_common_struct_table_t *struct_table;
    size_t index;
    libspdm_return_t status;
    uint32_t algo_size;
    uint8_t fixed_alg_size;
    uint8_t ext_alg_count;
    uint16_t ext_alg_total_count;
    uint8_t alg_type_pre;

<span style = "background-color:#dfd">    uint32_t hash_priority_table[] = {</span>
    #if LIBSPDM_SHA512_SUPPORT
        SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_512,
    #endif
    #if LIBSPDM_SHA384_SUPPORT
        SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_384,
    #endif
    #if LIBSPDM_SHA256_SUPPORT
        SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_256,
    #endif
    #if LIBSPDM_SHA3_512_SUPPORT
        SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_512,
    #endif
    #if LIBSPDM_SHA3_384_SUPPORT
        SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_384,
    #endif
    #if LIBSPDM_SHA3_256_SUPPORT
        SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_256,
    #endif
    #if LIBSPDM_SM3_256_SUPPORT
        SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SM3_256,
    #endif
        0,
    };

<span style = "background-color:#dfd">    uint32_t asym_priority_table[] = {</span>
    #if LIBSPDM_ECDSA_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256,
    #endif
    #if LIBSPDM_RSA_PSS_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048,
    #endif
    #if LIBSPDM_RSA_SSA_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048,
    #endif
    #if LIBSPDM_EDDSA_ED448_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448,
    #endif
    #if LIBSPDM_EDDSA_ED25519_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519,
    #endif
    #if LIBSPDM_SM2_DSA_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256,
    #endif
        0,
    };

<span style = "background-color:#dfd">    uint32_t req_asym_priority_table[] = {</span>
    #if LIBSPDM_ECDSA_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256,
    #endif
    #if LIBSPDM_RSA_PSS_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048,
    #endif
    #if LIBSPDM_RSA_SSA_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072,
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048,
    #endif
    #if LIBSPDM_EDDSA_ED448_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448,
    #endif
    #if LIBSPDM_EDDSA_ED25519_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519,
    #endif
    #if LIBSPDM_SM2_DSA_SUPPORT
        SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256,
    #endif
        0,
    };

<span style = "background-color:#dfd">    uint32_t dhe_priority_table[] = {</span>
    #if LIBSPDM_ECDHE_SUPPORT
        SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_521_R1,
        SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_384_R1,
        SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_256_R1,
    #endif
    #if LIBSPDM_FFDHE_SUPPORT
        SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_4096,
        SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_3072,
        SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_2048,
    #endif
    #if LIBSPDM_SM2_KEY_EXCHANGE_SUPPORT
        SPDM_ALGORITHMS_DHE_NAMED_GROUP_SM2_P256,
    #endif
        0,
    };

<span style = "background-color:#dfd">    uint32_t aead_priority_table[] = {</span>
    #if LIBSPDM_AEAD_GCM_SUPPORT
        SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_256_GCM,
        SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_128_GCM,
    #endif
    #if LIBSPDM_AEAD_CHACHA20_POLY1305_SUPPORT
        SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_CHACHA20_POLY1305,
    #endif
    #if LIBSPDM_AEAD_SM4_SUPPORT
        SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AEAD_SM4_GCM,
    #endif
        0,
    };

<span style = "background-color:#dfd">    uint32_t key_schedule_priority_table[] = {</span>
        SPDM_ALGORITHMS_KEY_SCHEDULE_HMAC_HASH,
    };

<span style = "background-color:#dfd">    uint32_t measurement_hash_priority_table[] = {</span>
    #if LIBSPDM_SHA512_SUPPORT
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_512,
    #endif
    #if LIBSPDM_SHA384_SUPPORT
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_384,
    #endif
    #if LIBSPDM_SHA256_SUPPORT
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_256,
    #endif
    #if LIBSPDM_SHA3_512_SUPPORT
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA3_512,
    #endif
    #if LIBSPDM_SHA3_384_SUPPORT
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA3_384,
    #endif
    #if LIBSPDM_SHA3_256_SUPPORT
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA3_256,
    #endif
    #if LIBSPDM_SM3_256_SUPPORT
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SM3_256,
    #endif
        SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_RAW_BIT_STREAM_ONLY,
    };

<span style = "background-color:#dfd">    uint32_t measurement_spec_priority_table[] = {</span>
        SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF,
    };

<span style = "background-color:#dfd">    uint32_t other_params_support_priority_table[] = {</span>
        SPDM_ALGORITHMS_OPAQUE_DATA_FORMAT_1,
    };

<span style = "background-color:#dfd">    spdm_request = request;</span>

<span style = "background-color:#dfd">    ext_alg_total_count = 0;</span>

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(!(((spdm_context-&gt;local_context.capability.flags &amp;</span>
                       SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP) == 0) ^
                     (spdm_context-&gt;local_context.algorithm.measurement_spec == 0)));

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(!(((spdm_context-&gt;local_context.capability.flags &amp;</span>
                       SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP) == 0) ^
                     (spdm_context-&gt;local_context.algorithm.measurement_hash_algo == 0)));

    /* -=[Verify State Phase]=- */
<span style = "background-color:#dfd">    if (spdm_context-&gt;response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {</span>
<span style = "background-color:#fdd">        return libspdm_responder_handle_response_state(</span>
            spdm_context,
            spdm_request-&gt;header.request_response_code,
            response_size, response);
    }
<span style = "background-color:#dfd">    if (spdm_context-&gt;connection_info.connection_state !=</span>
        LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES) {
<span style = "background-color:#fdd">        return libspdm_generate_error_response(spdm_context,</span>
                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,
                                               0, response_size, response);
    }

    /* -=[Validate Request Phase]=- */
<span style = "background-color:#dfd">    if (spdm_request-&gt;header.spdm_version != libspdm_get_connection_version(spdm_context)) {</span>
<span style = "background-color:#fdd">        return libspdm_generate_error_response(spdm_context,</span>
                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,
                                               response_size, response);
    }
<span style = "background-color:#dfd">    if (request_size &lt; sizeof(spdm_negotiate_algorithms_request_t)) {</span>
<span style = "background-color:#fdd">        return libspdm_generate_error_response(spdm_context,</span>
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }
<span style = "background-color:#dfd">    if (request_size &lt;</span>
        sizeof(spdm_negotiate_algorithms_request_t) +
        sizeof(uint32_t) * spdm_request-&gt;ext_asym_count +
        sizeof(uint32_t) * spdm_request-&gt;ext_hash_count +
        sizeof(spdm_negotiate_algorithms_common_struct_table_t) * spdm_request-&gt;header.param1) {
<span style = "background-color:#fdd">        return libspdm_generate_error_response(spdm_context,</span>
                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                                               response_size, response);
    }
<span style = "background-color:#dfd">    struct_table = (void *)((size_t)spdm_request +</span>
                            sizeof(spdm_negotiate_algorithms_request_t) +
                            sizeof(uint32_t) * spdm_request-&gt;ext_asym_count +
                            sizeof(uint32_t) * spdm_request-&gt;ext_hash_count);
<span style = "background-color:#dfd">    if (spdm_request-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_11) {
        alg_type_pre = struct_table-&gt;alg_type;
        for (index = 0; index &lt; spdm_request-&gt;header.param1; index++) {
            if ((size_t)spdm_request + request_size &lt; (size_t)struct_table) {</span>
<span style = "background-color:#fdd">                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
<span style = "background-color:#dfd">            if ((size_t)spdm_request + request_size - (size_t)struct_table &lt;</span>
                sizeof(spdm_negotiate_algorithms_common_struct_table_t)) {
<span style = "background-color:#fdd">                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
<span style = "background-color:#dfd">            if ((struct_table-&gt;alg_type &lt; SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_DHE) ||</span>
                (struct_table-&gt;alg_type &gt;
                 SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_KEY_SCHEDULE)) {
<span style = "background-color:#fdd">                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
            /* AlgType shall monotonically increase for subsequent entries. */
<span style = "background-color:#dfd">            if ((index != 0) &amp;&amp; (struct_table-&gt;alg_type &lt;= alg_type_pre)) {</span>
<span style = "background-color:#fdd">                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
<span style = "background-color:#dfd">            alg_type_pre = struct_table-&gt;alg_type;
            fixed_alg_size = (struct_table-&gt;alg_count &gt;&gt; 4) &amp; 0xF;
            ext_alg_count = struct_table-&gt;alg_count &amp; 0xF;
            ext_alg_total_count += ext_alg_count;
            if (fixed_alg_size != 2) {</span>
<span style = "background-color:#fdd">                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
            if ((size_t)spdm_request + request_size - (size_t)struct_table -
<span style = "background-color:#dfd">                sizeof(spdm_negotiate_algorithms_common_struct_table_t) &lt;</span>
                sizeof(uint32_t) * ext_alg_count) {
<span style = "background-color:#fdd">                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
<span style = "background-color:#dfd">            struct_table =</span>
                (void *)((size_t)struct_table +
                         sizeof(spdm_negotiate_algorithms_common_struct_table_t) +
                         sizeof(uint32_t) * ext_alg_count);
<span style = "background-color:#dfd">        }</span>
    }
<span style = "background-color:#dfd">    ext_alg_total_count += (spdm_request-&gt;ext_asym_count + spdm_request-&gt;ext_hash_count);</span>
    /* Algorithm count check and message size check*/
<span style = "background-color:#dfd">    if (spdm_request-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_11) {
        if (ext_alg_total_count &gt; SPDM_NEGOTIATE_ALGORITHMS_REQUEST_MAX_EXT_ALG_COUNT_VERSION_11) {</span>
<span style = "background-color:#fdd">            return libspdm_generate_error_response(</span>
                spdm_context,
                SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                response_size, response);
        }
<span style = "background-color:#dfd">        if (spdm_request-&gt;length &gt; SPDM_NEGOTIATE_ALGORITHMS_REQUEST_MAX_LENGTH_VERSION_11) {</span>
<span style = "background-color:#fdd">            return libspdm_generate_error_response(</span>
                spdm_context,
                SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                response_size, response);
        }
<span style = "background-color:#dfd">    } else {
        if (ext_alg_total_count &gt; SPDM_NEGOTIATE_ALGORITHMS_REQUEST_MAX_EXT_ALG_COUNT_VERSION_10) {</span>
<span style = "background-color:#fdd">            return libspdm_generate_error_response(</span>
                spdm_context,
                SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                response_size, response);
        }
<span style = "background-color:#dfd">        if (spdm_request-&gt;length &gt; SPDM_NEGOTIATE_ALGORITHMS_REQUEST_MAX_LENGTH_VERSION_10) {</span>
<span style = "background-color:#fdd">            return libspdm_generate_error_response(</span>
                spdm_context,
                SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                response_size, response);
        }
    }
<span style = "background-color:#dfd">    request_size = (size_t)struct_table - (size_t)spdm_request;
    if (request_size != spdm_request-&gt;length) {</span>
<span style = "background-color:#fdd">        return libspdm_generate_error_response(</span>
            spdm_context,
            SPDM_ERROR_CODE_INVALID_REQUEST, 0,
            response_size, response);
    }
<span style = "background-color:#dfd">    spdm_request_size = request_size;</span>

<span style = "background-color:#dfd">    libspdm_reset_message_buffer_via_request_code(spdm_context, NULL,</span>
                                                  spdm_request-&gt;header.request_response_code);

    /* -=[Construct Response Phase]=- */
<span style = "background-color:#dfd">    LIBSPDM_ASSERT(*response_size &gt;= sizeof(libspdm_algorithms_response_mine_t));
    *response_size = sizeof(libspdm_algorithms_response_mine_t);
    libspdm_zero_mem(response, *response_size);
    spdm_response = response;</span>

<span style = "background-color:#dfd">    spdm_response-&gt;header.spdm_version = spdm_request-&gt;header.spdm_version;
    if (spdm_request-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_11) {</span>
        /* Number of Algorithms Structure Tables */
<span style = "background-color:#dfd">        spdm_response-&gt;header.param1 = 4;
    } else {
        spdm_response-&gt;header.param1 = 0;
        *response_size =</span>
            sizeof(libspdm_algorithms_response_mine_t) -
            sizeof(spdm_negotiate_algorithms_common_struct_table_t) * 4;
    }
<span style = "background-color:#dfd">    spdm_response-&gt;header.request_response_code = SPDM_ALGORITHMS;
    spdm_response-&gt;header.param2 = 0;
    spdm_response-&gt;length = (uint16_t)*response_size;</span>

<span style = "background-color:#dfd">    spdm_context-&gt;connection_info.algorithm.measurement_spec =</span>
        spdm_request-&gt;measurement_specification;
<span style = "background-color:#dfd">    if (spdm_request-&gt;measurement_specification != 0) {
        spdm_context-&gt;connection_info.algorithm.measurement_hash_algo =</span>
            spdm_context-&gt;local_context.algorithm.measurement_hash_algo;
<span style = "background-color:#dfd">    } else {</span>
<span style = "background-color:#fdd">        spdm_context-&gt;connection_info.algorithm.measurement_hash_algo = 0;</span>
    }
<span style = "background-color:#dfd">    spdm_context-&gt;connection_info.algorithm.base_asym_algo = spdm_request-&gt;base_asym_algo;
    spdm_context-&gt;connection_info.algorithm.base_hash_algo = spdm_request-&gt;base_hash_algo;
    if (spdm_request-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_11) {
        struct_table =</span>
            (void *)((size_t)spdm_request +
                     sizeof(spdm_negotiate_algorithms_request_t) +
                     sizeof(uint32_t) * spdm_request-&gt;ext_asym_count +
                     sizeof(uint32_t) * spdm_request-&gt;ext_hash_count);
<span style = "background-color:#dfd">        for (index = 0; index &lt; spdm_request-&gt;header.param1; index++) {
            switch (struct_table-&gt;alg_type) {</span>
            case SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_DHE:
<span style = "background-color:#dfd">                spdm_context-&gt;connection_info.algorithm.dhe_named_group =</span>
                    struct_table-&gt;alg_supported;
<span style = "background-color:#dfd">                break;</span>
            case SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_AEAD:
<span style = "background-color:#dfd">                spdm_context-&gt;connection_info.algorithm.aead_cipher_suite =</span>
                    struct_table-&gt;alg_supported;
<span style = "background-color:#dfd">                break;</span>
            case SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_REQ_BASE_ASYM_ALG:
<span style = "background-color:#dfd">                spdm_context-&gt;connection_info.algorithm.req_base_asym_alg =</span>
                    struct_table-&gt;alg_supported;
<span style = "background-color:#dfd">                break;</span>
            case SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_KEY_SCHEDULE:
<span style = "background-color:#dfd">                spdm_context-&gt;connection_info.algorithm.key_schedule =</span>
                    struct_table-&gt;alg_supported;
                break;
            default:
                /* Unknown algorithm types do not need to be processed */
                break;
            }
<span style = "background-color:#dfd">            ext_alg_count = struct_table-&gt;alg_count &amp; 0xF;
            struct_table =</span>
                (void *)((size_t)struct_table +
                         sizeof(spdm_negotiate_algorithms_common_struct_table_t) +
                         sizeof(uint32_t) * ext_alg_count);
<span style = "background-color:#dfd">        }</span>
    }
<span style = "background-color:#dfd">    if (spdm_request-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_12) {
        spdm_context-&gt;connection_info.algorithm.other_params_support =</span>
            spdm_request-&gt;other_params_support;
    }

<span style = "background-color:#dfd">    spdm_response-&gt;measurement_specification_sel = (uint8_t)libspdm_prioritize_algorithm(</span>
        measurement_spec_priority_table,
        LIBSPDM_ARRAY_SIZE(measurement_spec_priority_table),
        spdm_context-&gt;local_context.algorithm.measurement_spec,
        spdm_context-&gt;connection_info.algorithm.measurement_spec);

<span style = "background-color:#dfd">    spdm_response-&gt;measurement_hash_algo = libspdm_prioritize_algorithm(</span>
        measurement_hash_priority_table,
        LIBSPDM_ARRAY_SIZE(measurement_hash_priority_table),
        spdm_context-&gt;local_context.algorithm.measurement_hash_algo,
        spdm_context-&gt;connection_info.algorithm.measurement_hash_algo);

<span style = "background-color:#dfd">    spdm_response-&gt;base_asym_sel = libspdm_prioritize_algorithm(</span>
        asym_priority_table, LIBSPDM_ARRAY_SIZE(asym_priority_table),
        spdm_context-&gt;local_context.algorithm.base_asym_algo,
        spdm_context-&gt;connection_info.algorithm.base_asym_algo);

<span style = "background-color:#dfd">    spdm_response-&gt;base_hash_sel = libspdm_prioritize_algorithm(</span>
        hash_priority_table, LIBSPDM_ARRAY_SIZE(hash_priority_table),
        spdm_context-&gt;local_context.algorithm.base_hash_algo,
        spdm_context-&gt;connection_info.algorithm.base_hash_algo);

<span style = "background-color:#dfd">    spdm_response-&gt;struct_table[0].alg_type = SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_DHE;
    spdm_response-&gt;struct_table[0].alg_count = 0x20;
    spdm_response-&gt;struct_table[0].alg_supported = (uint16_t)libspdm_prioritize_algorithm(</span>
        dhe_priority_table, LIBSPDM_ARRAY_SIZE(dhe_priority_table),
        spdm_context-&gt;local_context.algorithm.dhe_named_group,
        spdm_context-&gt;connection_info.algorithm.dhe_named_group);

<span style = "background-color:#dfd">    spdm_response-&gt;struct_table[1].alg_type = SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_AEAD;
    spdm_response-&gt;struct_table[1].alg_count = 0x20;
    spdm_response-&gt;struct_table[1].alg_supported = (uint16_t)libspdm_prioritize_algorithm(</span>
        aead_priority_table, LIBSPDM_ARRAY_SIZE(aead_priority_table),
        spdm_context-&gt;local_context.algorithm.aead_cipher_suite,
        spdm_context-&gt;connection_info.algorithm.aead_cipher_suite);

<span style = "background-color:#dfd">    spdm_response-&gt;struct_table[2].alg_type =</span>
        SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_REQ_BASE_ASYM_ALG;
<span style = "background-color:#dfd">    spdm_response-&gt;struct_table[2].alg_count = 0x20;
    spdm_response-&gt;struct_table[2].alg_supported = (uint16_t)libspdm_prioritize_algorithm(</span>
        req_asym_priority_table,
        LIBSPDM_ARRAY_SIZE(req_asym_priority_table),
        spdm_context-&gt;local_context.algorithm.req_base_asym_alg,
        spdm_context-&gt;connection_info.algorithm.req_base_asym_alg);

<span style = "background-color:#dfd">    spdm_response-&gt;struct_table[3].alg_type =</span>
        SPDM_NEGOTIATE_ALGORITHMS_STRUCT_TABLE_ALG_TYPE_KEY_SCHEDULE;
<span style = "background-color:#dfd">    spdm_response-&gt;struct_table[3].alg_count = 0x20;
    spdm_response-&gt;struct_table[3].alg_supported = (uint16_t)libspdm_prioritize_algorithm(</span>
        key_schedule_priority_table,
        LIBSPDM_ARRAY_SIZE(key_schedule_priority_table),
        spdm_context-&gt;local_context.algorithm.key_schedule,
        spdm_context-&gt;connection_info.algorithm.key_schedule);

<span style = "background-color:#dfd">    if (spdm_request-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_12) {
        spdm_response-&gt;other_params_selection = (uint8_t)libspdm_prioritize_algorithm(</span>
            other_params_support_priority_table,
            LIBSPDM_ARRAY_SIZE(other_params_support_priority_table),
            spdm_context-&gt;local_context.algorithm.other_params_support,
            spdm_context-&gt;connection_info.algorithm.other_params_support);
    }

<span style = "background-color:#dfd">    spdm_context-&gt;connection_info.algorithm.measurement_spec =</span>
        spdm_response-&gt;measurement_specification_sel;
<span style = "background-color:#dfd">    spdm_context-&gt;connection_info.algorithm.measurement_hash_algo =</span>
        spdm_response-&gt;measurement_hash_algo;
<span style = "background-color:#dfd">    spdm_context-&gt;connection_info.algorithm.base_asym_algo = spdm_response-&gt;base_asym_sel;
    spdm_context-&gt;connection_info.algorithm.base_hash_algo = spdm_response-&gt;base_hash_sel;</span>

    if (libspdm_is_capabilities_flag_supported(
            spdm_context, false, 0,
<span style = "background-color:#dfd">            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP) &amp;&amp;</span>
        (spdm_request-&gt;measurement_specification != 0)) {
<span style = "background-color:#dfd">        if (spdm_context-&gt;connection_info.algorithm.measurement_spec !=</span>
            SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF) {
<span style = "background-color:#fdd">            return libspdm_generate_error_response(</span>
                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST,
                0, response_size, response);
        }
<span style = "background-color:#dfd">        algo_size = libspdm_get_measurement_hash_size(</span>
            spdm_context-&gt;connection_info.algorithm.measurement_hash_algo);
<span style = "background-color:#dfd">        if (algo_size == 0) {</span>
<span style = "background-color:#fdd">            return libspdm_generate_error_response(</span>
                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST,
                0, response_size, response);
        }
    }

    if (libspdm_is_capabilities_flag_supported(
            spdm_context, false, 0,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CERT_CAP) ||
        libspdm_is_capabilities_flag_supported(
            spdm_context, false, 0,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHAL_CAP) ||
        libspdm_is_capabilities_flag_supported(
            spdm_context, false, 0,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_SIG) ||
        libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,
<span style = "background-color:#dfd">            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP) ||</span>
        libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PSK_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP)) {
<span style = "background-color:#dfd">        algo_size = libspdm_get_hash_size(</span>
            spdm_context-&gt;connection_info.algorithm.base_hash_algo);
<span style = "background-color:#dfd">        if (algo_size == 0) {
            return libspdm_generate_error_response(</span>
                spdm_context,
                SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                response_size, response);
        }
    }

    if (libspdm_is_capabilities_flag_supported(
            spdm_context, false, 0,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CERT_CAP) ||
        libspdm_is_capabilities_flag_supported(
            spdm_context, false, 0,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHAL_CAP) ||
        libspdm_is_capabilities_flag_supported(
            spdm_context, false, 0,
<span style = "background-color:#dfd">            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_SIG) ||</span>
        libspdm_is_capabilities_flag_supported(
            spdm_context, false,
            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,
            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP)) {
<span style = "background-color:#dfd">        algo_size = libspdm_get_asym_signature_size(</span>
            spdm_context-&gt;connection_info.algorithm.base_asym_algo);
<span style = "background-color:#dfd">        if (algo_size == 0) {</span>
<span style = "background-color:#fdd">            return libspdm_generate_error_response(</span>
                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST,
                0, response_size, response);
        }
    }

    /* -=[Process Request Phase]=- */
<span style = "background-color:#dfd">    if (spdm_response-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_11) {
        spdm_context-&gt;connection_info.algorithm.dhe_named_group =</span>
            spdm_response-&gt;struct_table[0].alg_supported;
<span style = "background-color:#dfd">        spdm_context-&gt;connection_info.algorithm.aead_cipher_suite =</span>
            spdm_response-&gt;struct_table[1].alg_supported;
<span style = "background-color:#dfd">        spdm_context-&gt;connection_info.algorithm.req_base_asym_alg =</span>
            spdm_response-&gt;struct_table[2].alg_supported;
<span style = "background-color:#dfd">        spdm_context-&gt;connection_info.algorithm.key_schedule =</span>
            spdm_response-&gt;struct_table[3].alg_supported;
<span style = "background-color:#dfd">        if (spdm_response-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_12) {
            spdm_context-&gt;connection_info.algorithm.other_params_support =</span>
                spdm_response-&gt;other_params_selection;
<span style = "background-color:#dfd">        } else {
            spdm_context-&gt;connection_info.algorithm.other_params_support = 0;</span>
        }

<span style = "background-color:#dfd">        if (libspdm_is_capabilities_flag_supported(</span>
                spdm_context, false,
                SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,
                SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP)) {
<span style = "background-color:#fdd">            algo_size = libspdm_get_dhe_pub_key_size(</span>
                spdm_context-&gt;connection_info.algorithm.dhe_named_group);
<span style = "background-color:#fdd">            if (algo_size == 0) {
                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
        }
        if (libspdm_is_capabilities_flag_supported(
                spdm_context, false,
                SPDM_GET_CAPABILITIES_REQUEST_FLAGS_ENCRYPT_CAP,
<span style = "background-color:#dfd">                SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_ENCRYPT_CAP) ||</span>
            libspdm_is_capabilities_flag_supported(
                spdm_context, false,
                SPDM_GET_CAPABILITIES_REQUEST_FLAGS_MAC_CAP,
                SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MAC_CAP)) {
<span style = "background-color:#fdd">            algo_size = libspdm_get_aead_key_size(</span>
                spdm_context-&gt;connection_info.algorithm.aead_cipher_suite);
<span style = "background-color:#fdd">            if (algo_size == 0) {
                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
        }
<span style = "background-color:#dfd">        if (libspdm_is_capabilities_flag_supported(</span>
                spdm_context, false,
                SPDM_GET_CAPABILITIES_REQUEST_FLAGS_MUT_AUTH_CAP,
                SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MUT_AUTH_CAP)) {
<span style = "background-color:#fdd">            algo_size = libspdm_get_req_asym_signature_size(</span>
                spdm_context-&gt;connection_info.algorithm.req_base_asym_alg);
<span style = "background-color:#fdd">            if (algo_size == 0) {
                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
        }
        if (libspdm_is_capabilities_flag_supported(
                spdm_context, false,
                SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,
<span style = "background-color:#dfd">                SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP) ||</span>
            libspdm_is_capabilities_flag_supported(
                spdm_context, false,
                SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PSK_CAP,
                SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP)) {
<span style = "background-color:#fdd">            if (spdm_context-&gt;connection_info.algorithm.key_schedule !=</span>
                SPDM_ALGORITHMS_KEY_SCHEDULE_HMAC_HASH) {
<span style = "background-color:#fdd">                return libspdm_generate_error_response(</span>
                    spdm_context,
                    SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                    response_size, response);
            }
<span style = "background-color:#fdd">            if (spdm_response-&gt;header.spdm_version &gt;= SPDM_MESSAGE_VERSION_12) {</span>
                if ((spdm_context-&gt;connection_info.algorithm.other_params_support &amp;
<span style = "background-color:#fdd">                     SPDM_ALGORITHMS_OPAQUE_DATA_FORMAT_MASK) !=</span>
                    SPDM_ALGORITHMS_OPAQUE_DATA_FORMAT_1) {
<span style = "background-color:#fdd">                    return libspdm_generate_error_response(</span>
                        spdm_context,
                        SPDM_ERROR_CODE_INVALID_REQUEST, 0,
                        response_size, response);
                }
            }
        }
<span style = "background-color:#dfd">    } else {
        spdm_context-&gt;connection_info.algorithm.dhe_named_group = 0;
        spdm_context-&gt;connection_info.algorithm.aead_cipher_suite = 0;
        spdm_context-&gt;connection_info.algorithm.req_base_asym_alg = 0;
        spdm_context-&gt;connection_info.algorithm.key_schedule = 0;
        spdm_context-&gt;connection_info.algorithm.other_params_support = 0;</span>
    }

<span style = "background-color:#dfd">    status = libspdm_append_message_a(spdm_context, spdm_request, spdm_request_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {</span>
<span style = "background-color:#fdd">        return libspdm_generate_error_response(spdm_context,</span>
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

<span style = "background-color:#dfd">    status = libspdm_append_message_a(spdm_context, spdm_response, *response_size);
    if (LIBSPDM_STATUS_IS_ERROR(status)) {</span>
<span style = "background-color:#fdd">        return libspdm_generate_error_response(spdm_context,</span>
                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,
                                               response_size, response);
    }

    /* -=[Update State Phase]=- */
<span style = "background-color:#dfd">    libspdm_set_connection_state(spdm_context, LIBSPDM_CONNECTION_STATE_NEGOTIATED);</span>

<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>