<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>libspdm_secmes_encode_decode.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/**
 *  Copyright Notice:
 *  Copyright 2021-2022 DMTF. All rights reserved.
 *  License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libspdm/blob/main/LICENSE.md
 **/

#include "internal/libspdm_secured_message_lib.h"

/**
 * Encode an application message to a secured message.
 *
 * @param  spdm_secured_message_context    A pointer to the SPDM secured message context.
 * @param  session_id                    The session ID of the SPDM session.
 * @param  is_requester                  Indicates if it is a requester message.
 * @param  app_message_size               size in bytes of the application message data buffer.
 * @param  app_message                   A pointer to a source buffer to store the application message.
 *                                       It shall point to the scratch buffer in spdm_context.
 *                                         Before app_message, there is room for spdm_secured_message_cipher_header_t.
 *                                         After (app_message + app_message_size), there is room for random bytes.
 * @param  secured_message_size           size in bytes of the secured message data buffer.
 * @param  secured_message               A pointer to a destination buffer to store the secured message.
 *                                       It shall point to the acquired sender buffer.
 * @param  spdm_secured_message_callbacks  A pointer to a secured message callback functions structure.
 *
 * @retval RETURN_SUCCESS               The application message is encoded successfully.
 * @retval RETURN_INVALID_PARAMETER     The message is NULL or the message_size is zero.
 **/
libspdm_return_t libspdm_encode_secured_message(
    void *spdm_secured_message_context, uint32_t session_id,
    bool is_requester, size_t app_message_size,
    void *app_message, size_t *secured_message_size,
    void *secured_message,
    const libspdm_secured_message_callbacks_t *spdm_secured_message_callbacks)
<span style = "background-color:#fdd">{</span>
    libspdm_secured_message_context_t *secured_message_context;
    size_t total_secured_message_size;
    size_t plain_text_size;
    size_t cipher_text_size;
    size_t aead_tag_size;
    size_t aead_key_size;
    size_t aead_iv_size;
    uint8_t *a_data;
    uint8_t *enc_msg;
    uint8_t *dec_msg;
    uint8_t *tag;
    spdm_secured_message_a_data_header1_t *record_header1;
    spdm_secured_message_a_data_header2_t *record_header2;
    size_t record_header_size;
    spdm_secured_message_cipher_header_t *enc_msg_header;
    bool result;
    const uint8_t *key;
    uint8_t *salt;
    uint64_t sequence_number;
    uint64_t sequence_num_in_header;
    uint64_t data64;
    uint8_t sequence_num_in_header_size;
    libspdm_session_type_t session_type;
    uint32_t rand_count;
    uint32_t max_rand_count;
    libspdm_session_state_t session_state;

<span style = "background-color:#fdd">    secured_message_context = spdm_secured_message_context;</span>

<span style = "background-color:#fdd">    session_type = secured_message_context-&gt;session_type;
    LIBSPDM_ASSERT((session_type == LIBSPDM_SESSION_TYPE_MAC_ONLY) ||</span>
                   (session_type == LIBSPDM_SESSION_TYPE_ENC_MAC));
<span style = "background-color:#fdd">    session_state = secured_message_context-&gt;session_state;
    LIBSPDM_ASSERT((session_state == LIBSPDM_SESSION_STATE_HANDSHAKING) ||</span>
                   (session_state == LIBSPDM_SESSION_STATE_ESTABLISHED));

<span style = "background-color:#fdd">    aead_tag_size = secured_message_context-&gt;aead_tag_size;
    aead_key_size = secured_message_context-&gt;aead_key_size;
    aead_iv_size = secured_message_context-&gt;aead_iv_size;</span>

<span style = "background-color:#fdd">    switch (session_state) {</span>
    case LIBSPDM_SESSION_STATE_HANDSHAKING:
<span style = "background-color:#fdd">        if (is_requester) {
            key = (const uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                  request_handshake_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                   request_handshake_salt;
<span style = "background-color:#fdd">            sequence_number = secured_message_context-&gt;handshake_secret</span>
                              .request_handshake_sequence_number;
<span style = "background-color:#fdd">        } else {
            key = (const uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                  response_handshake_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                   response_handshake_salt;
<span style = "background-color:#fdd">            sequence_number = secured_message_context-&gt;handshake_secret</span>
                              .response_handshake_sequence_number;
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_SESSION_STATE_ESTABLISHED:
<span style = "background-color:#fdd">        if (is_requester) {
            key = (const uint8_t *)secured_message_context-&gt;application_secret.</span>
                  request_data_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;application_secret.</span>
                   request_data_salt;
<span style = "background-color:#fdd">            sequence_number = secured_message_context-&gt;application_secret</span>
                              .request_data_sequence_number;
<span style = "background-color:#fdd">        } else {
            key = (const uint8_t *)secured_message_context-&gt;application_secret.</span>
                  response_data_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;application_secret.</span>
                   response_data_salt;
<span style = "background-color:#fdd">            sequence_number = secured_message_context-&gt;application_secret</span>
                              .response_data_sequence_number;
        }
<span style = "background-color:#fdd">        break;</span>
    default:
<span style = "background-color:#fdd">        LIBSPDM_ASSERT(false);
        return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
        break;
    }

<span style = "background-color:#fdd">    if (sequence_number == (uint64_t)-1) {
        return LIBSPDM_STATUS_SEQUENCE_NUMBER_OVERFLOW;</span>
    }

<span style = "background-color:#fdd">    if (sequence_number &gt; 0) {
        data64 = libspdm_read_uint64((const uint8_t *)salt) ^</span>
                 (sequence_number - 1) ^ sequence_number;
<span style = "background-color:#fdd">        libspdm_write_uint64(salt, data64);</span>
    }

<span style = "background-color:#fdd">    sequence_num_in_header = 0;
    sequence_num_in_header_size = spdm_secured_message_callbacks-&gt;get_sequence_number(</span>
        sequence_number, (uint8_t *)&amp;sequence_num_in_header);
<span style = "background-color:#fdd">    LIBSPDM_ASSERT(sequence_num_in_header_size &lt;= sizeof(sequence_num_in_header));</span>

<span style = "background-color:#fdd">    sequence_number++;
    if (session_state == LIBSPDM_SESSION_STATE_HANDSHAKING) {
        if (is_requester) {
            secured_message_context-&gt;handshake_secret.request_handshake_sequence_number =</span>
                sequence_number;
<span style = "background-color:#fdd">        } else {
            secured_message_context-&gt;handshake_secret.response_handshake_sequence_number =</span>
                sequence_number;
        }
<span style = "background-color:#fdd">    }</span>
    else {
<span style = "background-color:#fdd">        if (is_requester) {
            secured_message_context-&gt;application_secret.request_data_sequence_number =</span>
                sequence_number;
<span style = "background-color:#fdd">        } else {
            secured_message_context-&gt;application_secret.response_data_sequence_number =</span>
                sequence_number;
        }
    }

<span style = "background-color:#fdd">    record_header_size = sizeof(spdm_secured_message_a_data_header1_t) +</span>
                         sequence_num_in_header_size +
                         sizeof(spdm_secured_message_a_data_header2_t);

<span style = "background-color:#fdd">    switch (session_type) {</span>
    case LIBSPDM_SESSION_TYPE_ENC_MAC:
<span style = "background-color:#fdd">        max_rand_count = spdm_secured_message_callbacks-&gt;get_max_random_number_count();
        if (max_rand_count != 0) {
            rand_count = 0;
            result = libspdm_get_random_number(sizeof(rand_count), (uint8_t *)&amp;rand_count);
            if (!result) {
                return LIBSPDM_STATUS_LOW_ENTROPY;</span>
            }
<span style = "background-color:#fdd">            rand_count = (uint8_t)((rand_count % max_rand_count) + 1);
        } else {
            rand_count = 0;</span>
        }

<span style = "background-color:#fdd">        plain_text_size = sizeof(spdm_secured_message_cipher_header_t) + app_message_size +</span>
                          rand_count;
<span style = "background-color:#fdd">        cipher_text_size = plain_text_size;
        total_secured_message_size = record_header_size + cipher_text_size + aead_tag_size;</span>

<span style = "background-color:#fdd">        LIBSPDM_ASSERT(*secured_message_size &gt;= total_secured_message_size);
        if (*secured_message_size &lt; total_secured_message_size) {
            *secured_message_size = total_secured_message_size;
            return LIBSPDM_STATUS_BUFFER_TOO_SMALL;</span>
        }
<span style = "background-color:#fdd">        *secured_message_size = total_secured_message_size;
        record_header1 = (void *)secured_message;
        record_header2 = (void *)((uint8_t *)record_header1 +</span>
                                  sizeof(spdm_secured_message_a_data_header1_t) +
                                  sequence_num_in_header_size);
<span style = "background-color:#fdd">        record_header1-&gt;session_id = session_id;
        libspdm_copy_mem(record_header1 + 1,</span>
                         *secured_message_size
                         - ((uint8_t*)(record_header1 + 1) - (uint8_t*)secured_message),
                         &amp;sequence_num_in_header,
                         sequence_num_in_header_size);
<span style = "background-color:#fdd">        record_header2-&gt;length = (uint16_t)(cipher_text_size + aead_tag_size);</span>

<span style = "background-color:#fdd">        enc_msg_header =</span>
            (void *)((uint8_t *)app_message - sizeof(spdm_secured_message_cipher_header_t));
<span style = "background-color:#fdd">        enc_msg_header-&gt;application_data_length = (uint16_t)app_message_size;
        result = libspdm_get_random_number(rand_count,</span>
                                           (uint8_t *)enc_msg_header +
                                           sizeof(spdm_secured_message_cipher_header_t) +
                                           app_message_size);
<span style = "background-color:#fdd">        if (!result) {
            return LIBSPDM_STATUS_LOW_ENTROPY;</span>
        }

<span style = "background-color:#fdd">        a_data = (uint8_t *)record_header1;
        enc_msg = (uint8_t *)(record_header2 + 1);
        dec_msg = (uint8_t *)enc_msg_header;
        tag = (uint8_t *)record_header1 + record_header_size +</span>
              cipher_text_size;

<span style = "background-color:#fdd">        result = libspdm_aead_encryption(</span>
            secured_message_context-&gt;secured_message_version,
            secured_message_context-&gt;aead_cipher_suite, key,
            aead_key_size, salt, aead_iv_size, (uint8_t *)a_data,
            record_header_size, dec_msg, cipher_text_size, tag,
            aead_tag_size, enc_msg, &amp;cipher_text_size);
<span style = "background-color:#fdd">        break;</span>

    case LIBSPDM_SESSION_TYPE_MAC_ONLY:
<span style = "background-color:#fdd">        total_secured_message_size =</span>
            record_header_size + app_message_size + aead_tag_size;

<span style = "background-color:#fdd">        LIBSPDM_ASSERT(*secured_message_size &gt;= total_secured_message_size);
        if (*secured_message_size &lt; total_secured_message_size) {
            *secured_message_size = total_secured_message_size;
            return LIBSPDM_STATUS_BUFFER_TOO_SMALL;</span>
        }
<span style = "background-color:#fdd">        *secured_message_size = total_secured_message_size;
        record_header1 = (void *)secured_message;
        record_header2 =</span>
            (void *)((uint8_t *)record_header1 +
                     sizeof(spdm_secured_message_a_data_header1_t) +
                     sequence_num_in_header_size);
<span style = "background-color:#fdd">        record_header1-&gt;session_id = session_id;
        libspdm_copy_mem(record_header1 + 1,</span>
                         *secured_message_size
                         - ((uint8_t*)(record_header1 + 1) - (uint8_t*)secured_message),
                         &amp;sequence_num_in_header,
                         sequence_num_in_header_size);
<span style = "background-color:#fdd">        record_header2-&gt;length =</span>
            (uint16_t)(app_message_size + aead_tag_size);
<span style = "background-color:#fdd">        libspdm_copy_mem(record_header2 + 1,</span>
                         *secured_message_size
                         - ((uint8_t*)(record_header2 + 1) - (uint8_t*)secured_message),
                         app_message, app_message_size);
<span style = "background-color:#fdd">        a_data = (uint8_t *)record_header1;
        tag = (uint8_t *)record_header1 + record_header_size + app_message_size;</span>

<span style = "background-color:#fdd">        result = libspdm_aead_encryption(</span>
            secured_message_context-&gt;secured_message_version,
            secured_message_context-&gt;aead_cipher_suite, key,
            aead_key_size, salt, aead_iv_size, (uint8_t *)a_data,
            record_header_size + app_message_size, NULL, 0, tag,
            aead_tag_size, NULL, NULL);
<span style = "background-color:#fdd">        break;</span>

    default:
<span style = "background-color:#fdd">        LIBSPDM_ASSERT(false);
        return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
    }
<span style = "background-color:#fdd">    if (!result) {
        return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
    }
<span style = "background-color:#fdd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

/**
 * Decode an application message from a secured message.
 *
 * @param  spdm_secured_message_context    A pointer to the SPDM secured message context.
 * @param  session_id                    The session ID of the SPDM session.
 * @param  is_requester                  Indicates if it is a requester message.
 * @param  secured_message_size           size in bytes of the secured message data buffer.
 * @param  secured_message               A pointer to a source buffer to store the secured message.
 *                                       It shall point to the acquired receiver buffer.
 * @param  app_message_size               size in bytes of the application message data buffer.
 * @param  app_message                   A pointer to a destination buffer to store the application message.
 *                                       It shall point to the scratch buffer in spdm_context.
 *                                       On input, the app_message pointer shall point to a big enough buffer to hold the decrypted message
 *                                       On output, the app_message pointer shall be inside of [app_message, app_message + app_message_size]
 * @param  spdm_secured_message_callbacks  A pointer to a secured message callback functions structure.
 *
 * @retval RETURN_SUCCESS               The application message is decoded successfully.
 * @retval RETURN_INVALID_PARAMETER     The message is NULL or the message_size is zero.
 * @retval RETURN_UNSUPPORTED           The secured_message is unsupported.
 **/
libspdm_return_t libspdm_decode_secured_message(
    void *spdm_secured_message_context, uint32_t session_id,
    bool is_requester, size_t secured_message_size,
    void *secured_message, size_t *app_message_size,
    void **app_message,
    const libspdm_secured_message_callbacks_t *spdm_secured_message_callbacks)
<span style = "background-color:#fdd">{</span>
    libspdm_secured_message_context_t *secured_message_context;
    size_t plain_text_size;
    size_t cipher_text_size;
    size_t aead_tag_size;
    size_t aead_key_size;
    size_t aead_iv_size;
    const uint8_t *a_data;
    const uint8_t *enc_msg;
    uint8_t *dec_msg;
    const uint8_t *tag;
    spdm_secured_message_a_data_header1_t *record_header1;
    spdm_secured_message_a_data_header2_t *record_header2;
    size_t record_header_size;
    spdm_secured_message_cipher_header_t *enc_msg_header;
    bool result;
    const uint8_t *key;
    uint8_t *salt;
    uint64_t sequence_number;
    uint64_t sequence_num_in_header;
    uint64_t data64;
    uint8_t sequence_num_in_header_size;
    libspdm_session_type_t session_type;
    libspdm_session_state_t session_state;
    libspdm_error_struct_t spdm_error;

<span style = "background-color:#fdd">    spdm_error.error_code = 0;
    spdm_error.session_id = 0;
    libspdm_secured_message_set_last_spdm_error_struct(spdm_secured_message_context, &amp;spdm_error);</span>

<span style = "background-color:#fdd">    spdm_error.error_code = SPDM_ERROR_CODE_DECRYPT_ERROR;
    spdm_error.session_id = session_id;</span>

<span style = "background-color:#fdd">    secured_message_context = spdm_secured_message_context;</span>

<span style = "background-color:#fdd">    session_type = secured_message_context-&gt;session_type;
    LIBSPDM_ASSERT((session_type == LIBSPDM_SESSION_TYPE_MAC_ONLY) ||</span>
                   (session_type == LIBSPDM_SESSION_TYPE_ENC_MAC));
<span style = "background-color:#fdd">    session_state = secured_message_context-&gt;session_state;
    LIBSPDM_ASSERT((session_state == LIBSPDM_SESSION_STATE_HANDSHAKING) ||</span>
                   (session_state == LIBSPDM_SESSION_STATE_ESTABLISHED));

<span style = "background-color:#fdd">    aead_tag_size = secured_message_context-&gt;aead_tag_size;
    aead_key_size = secured_message_context-&gt;aead_key_size;
    aead_iv_size = secured_message_context-&gt;aead_iv_size;</span>

<span style = "background-color:#fdd">    switch (session_state) {</span>
    case LIBSPDM_SESSION_STATE_HANDSHAKING:
<span style = "background-color:#fdd">        if (is_requester) {
            key = (const uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                  request_handshake_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                   request_handshake_salt;
<span style = "background-color:#fdd">            sequence_number =</span>
                secured_message_context-&gt;handshake_secret.request_handshake_sequence_number;
<span style = "background-color:#fdd">        } else {
            key = (const uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                  response_handshake_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;handshake_secret.</span>
                   response_handshake_salt;
<span style = "background-color:#fdd">            sequence_number =</span>
                secured_message_context-&gt;handshake_secret.response_handshake_sequence_number;
        }
<span style = "background-color:#fdd">        break;</span>
    case LIBSPDM_SESSION_STATE_ESTABLISHED:
<span style = "background-color:#fdd">        if (is_requester) {
            key = (const uint8_t *)secured_message_context-&gt;application_secret.</span>
                  request_data_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;application_secret.</span>
                   request_data_salt;
<span style = "background-color:#fdd">            sequence_number =</span>
                secured_message_context-&gt;application_secret.request_data_sequence_number;
<span style = "background-color:#fdd">        } else {
            key = (const uint8_t *)secured_message_context-&gt;application_secret.</span>
                  response_data_encryption_key;
<span style = "background-color:#fdd">            salt = (uint8_t *)secured_message_context-&gt;application_secret.</span>
                   response_data_salt;
<span style = "background-color:#fdd">            sequence_number =</span>
                secured_message_context-&gt;application_secret.response_data_sequence_number;
        }
<span style = "background-color:#fdd">        break;</span>
    default:
<span style = "background-color:#fdd">        LIBSPDM_ASSERT(false);
        return LIBSPDM_STATUS_INVALID_STATE_LOCAL;</span>
    }

<span style = "background-color:#fdd">    if (sequence_number == (uint64_t)-1) {
        libspdm_secured_message_set_last_spdm_error_struct(</span>
            spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_SEQUENCE_NUMBER_OVERFLOW;</span>
    }

<span style = "background-color:#fdd">    if (sequence_number &gt; 0) {
        data64 = libspdm_read_uint64((const uint8_t *)salt) ^</span>
                 (sequence_number - 1) ^ sequence_number;
<span style = "background-color:#fdd">        libspdm_write_uint64(salt, data64);</span>
    }

<span style = "background-color:#fdd">    sequence_num_in_header = 0;
    sequence_num_in_header_size =</span>
        spdm_secured_message_callbacks-&gt;get_sequence_number(
            sequence_number, (uint8_t *)&amp;sequence_num_in_header);
<span style = "background-color:#fdd">    LIBSPDM_ASSERT(sequence_num_in_header_size &lt;= sizeof(sequence_num_in_header));</span>

<span style = "background-color:#fdd">    sequence_number++;
    if (session_state == LIBSPDM_SESSION_STATE_HANDSHAKING) {
        if (is_requester) {
            secured_message_context-&gt;handshake_secret.request_handshake_sequence_number =</span>
                sequence_number;
<span style = "background-color:#fdd">        } else {
            secured_message_context-&gt;handshake_secret.response_handshake_sequence_number =</span>
                sequence_number;
        }
<span style = "background-color:#fdd">    }</span>
    else {
<span style = "background-color:#fdd">        if (is_requester) {
            secured_message_context-&gt;application_secret.request_data_sequence_number =</span>
                sequence_number;
<span style = "background-color:#fdd">        } else {
            secured_message_context-&gt;application_secret.response_data_sequence_number =</span>
                sequence_number;
        }
    }

<span style = "background-color:#fdd">    record_header_size = sizeof(spdm_secured_message_a_data_header1_t) +</span>
                         sequence_num_in_header_size +
                         sizeof(spdm_secured_message_a_data_header2_t);

<span style = "background-color:#fdd">    switch (session_type) {</span>
    case LIBSPDM_SESSION_TYPE_ENC_MAC:
<span style = "background-color:#fdd">        if (secured_message_size &lt; record_header_size + aead_tag_size) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }
<span style = "background-color:#fdd">        record_header1 = secured_message;
        record_header2 =</span>
            (void *)((uint8_t *)record_header1 +
                     sizeof(spdm_secured_message_a_data_header1_t) +
                     sequence_num_in_header_size);
<span style = "background-color:#fdd">        if (record_header1-&gt;session_id != session_id) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
        }
        if (!libspdm_consttime_is_mem_equal(record_header1 + 1, &amp;sequence_num_in_header,
<span style = "background-color:#fdd">                                            sequence_num_in_header_size) != 0) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
        }
<span style = "background-color:#fdd">        if (record_header2-&gt;length &gt; secured_message_size - record_header_size) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }
<span style = "background-color:#fdd">        if (record_header2-&gt;length &lt; aead_tag_size) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }
<span style = "background-color:#fdd">        cipher_text_size = (record_header2-&gt;length - aead_tag_size);
        if (cipher_text_size &gt; *app_message_size) {
            return LIBSPDM_STATUS_BUFFER_TOO_SMALL;</span>
        }
<span style = "background-color:#fdd">        libspdm_zero_mem(*app_message, *app_message_size);
        enc_msg_header = (void *)(record_header2 + 1);
        a_data = (const uint8_t *)record_header1;
        enc_msg = (const uint8_t *)enc_msg_header;
        dec_msg = (uint8_t *)*app_message;
        enc_msg_header = (void *)dec_msg;
        tag = (const uint8_t *)record_header1 + record_header_size + cipher_text_size;
        result = libspdm_aead_decryption(</span>
            secured_message_context-&gt;secured_message_version,
            secured_message_context-&gt;aead_cipher_suite, key,
            aead_key_size, salt, aead_iv_size, a_data,
            record_header_size, enc_msg, cipher_text_size, tag,
            aead_tag_size, dec_msg, &amp;cipher_text_size);
<span style = "background-color:#fdd">        if (!result) {</span>
            /* Backup keys are valid, fail and alert rollback and retry is possible. */
<span style = "background-color:#fdd">            if ((is_requester &amp;&amp; secured_message_context-&gt;requester_backup_valid) ||</span>
                ((!is_requester) &amp;&amp; secured_message_context-&gt;responder_backup_valid)) {
<span style = "background-color:#fdd">                return LIBSPDM_STATUS_SESSION_TRY_DISCARD_KEY_UPDATE;</span>
            }

<span style = "background-color:#fdd">            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
        }
<span style = "background-color:#fdd">        plain_text_size = enc_msg_header-&gt;application_data_length;
        if (plain_text_size &gt; cipher_text_size) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }

<span style = "background-color:#fdd">        LIBSPDM_ASSERT(*app_message_size &gt;= plain_text_size);
        *app_message = enc_msg_header + 1;
        *app_message_size = plain_text_size;
        break;</span>

    case LIBSPDM_SESSION_TYPE_MAC_ONLY:
<span style = "background-color:#fdd">        if (secured_message_size &lt; record_header_size + aead_tag_size) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }
<span style = "background-color:#fdd">        record_header1 = secured_message;
        record_header2 =</span>
            (void *)((uint8_t *)record_header1 +
                     sizeof(spdm_secured_message_a_data_header1_t) +
                     sequence_num_in_header_size);
<span style = "background-color:#fdd">        if (record_header1-&gt;session_id != session_id) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
        }
<span style = "background-color:#fdd">        if (!libspdm_consttime_is_mem_equal(record_header1 + 1, &amp;sequence_num_in_header,</span>
                                            sequence_num_in_header_size)) {
<span style = "background-color:#fdd">            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
        }
<span style = "background-color:#fdd">        if (record_header2-&gt;length &gt;</span>
            secured_message_size - record_header_size) {
<span style = "background-color:#fdd">            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }
<span style = "background-color:#fdd">        if (record_header2-&gt;length &lt; aead_tag_size) {
            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }
<span style = "background-color:#fdd">        a_data = (uint8_t *)record_header1;
        tag = (uint8_t *)record_header1 + record_header_size +</span>
              record_header2-&gt;length - aead_tag_size;
<span style = "background-color:#fdd">        result = libspdm_aead_decryption(</span>
            secured_message_context-&gt;secured_message_version,
            secured_message_context-&gt;aead_cipher_suite, key,
            aead_key_size, salt, aead_iv_size, a_data,
            record_header_size + record_header2-&gt;length -
            aead_tag_size,
            NULL, 0, tag, aead_tag_size, NULL, NULL);
<span style = "background-color:#fdd">        if (!result) {</span>
            /* Backup keys are valid, fail and alert rollback and retry is possible. */
<span style = "background-color:#fdd">            if ((is_requester &amp;&amp; secured_message_context-&gt;requester_backup_valid) ||</span>
                ((!is_requester) &amp;&amp; secured_message_context-&gt;responder_backup_valid)) {
<span style = "background-color:#fdd">                return LIBSPDM_STATUS_SESSION_TRY_DISCARD_KEY_UPDATE;</span>
            }

<span style = "background-color:#fdd">            libspdm_secured_message_set_last_spdm_error_struct(</span>
                spdm_secured_message_context, &amp;spdm_error);
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_CRYPTO_ERROR;</span>
        }

<span style = "background-color:#fdd">        plain_text_size = record_header2-&gt;length - aead_tag_size;
        LIBSPDM_ASSERT(*app_message_size &gt;= plain_text_size);
        *app_message = record_header2 + 1;
        *app_message_size = plain_text_size;
        break;</span>

    default:
<span style = "background-color:#fdd">        LIBSPDM_ASSERT(false);
        return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
    }

<span style = "background-color:#fdd">    return LIBSPDM_STATUS_SUCCESS;
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>