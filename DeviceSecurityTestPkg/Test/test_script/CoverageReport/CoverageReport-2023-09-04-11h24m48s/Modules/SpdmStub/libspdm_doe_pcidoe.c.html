<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>libspdm_doe_pcidoe.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/**
 *  Copyright Notice:
 *  Copyright 2021-2022 DMTF. All rights reserved.
 *  License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libspdm/blob/main/LICENSE.md
 **/

#include "library/spdm_transport_pcidoe_lib.h"
#include "industry_standard/pcidoe.h"
#include "internal/libspdm_common_lib.h"
#include "hal/library/debuglib.h"
#include "hal/library/memlib.h"

/**
 * Get sequence number in an SPDM secure message.
 *
 * This value is transport layer specific.
 *
 * @param sequence_number        The current sequence number used to encode or decode message.
 * @param sequence_number_buffer  A buffer to hold the sequence number output used in the secured message.
 *                             The size in byte of the output buffer shall be 8.
 *
 * @return size in byte of the sequence_number_buffer.
 *        It shall be no greater than 8.
 *        0 means no sequence number is required.
 **/
uint8_t libspdm_pci_doe_get_sequence_number(uint64_t sequence_number,
                                            uint8_t *sequence_number_buffer)
<span style = "background-color:#fdd">{
    libspdm_copy_mem(sequence_number_buffer, LIBSPDM_PCI_DOE_SEQUENCE_NUMBER_COUNT,</span>
                     &amp;sequence_number, LIBSPDM_PCI_DOE_SEQUENCE_NUMBER_COUNT);
<span style = "background-color:#fdd">    return LIBSPDM_PCI_DOE_SEQUENCE_NUMBER_COUNT;
}</span>

/**
 * Return max random number count in an SPDM secure message.
 *
 * This value is transport layer specific.
 *
 * @return Max random number count in an SPDM secured message.
 *        0 means no random number is required.
 **/
uint32_t libspdm_pci_doe_get_max_random_number_count(void)
<span style = "background-color:#dfd">{
    return LIBSPDM_PCI_DOE_MAX_RANDOM_NUMBER_COUNT;
}</span>

/**
 * This function translates the negotiated secured_message_version to a DSP0277 version.
 *
 * @param  secured_message_version  The version specified in binding specification and
 *                                  negotiated in KEY_EXCHANGE/KEY_EXCHANGE_RSP.
 *
 * @return The DSP0277 version specified in binding specification,
 *         which is bound to secured_message_version.
 */
spdm_version_number_t libspdm_pci_doe_get_secured_spdm_version(
    spdm_version_number_t secured_message_version)
<span style = "background-color:#fdd">{</span>
    /* PCI-SIG uses DSP0277 version */
<span style = "background-color:#fdd">    return secured_message_version;
}</span>

/**
 * Encode a normal message or secured message to a transport message.
 *
 * @param  session_id                    Indicates if it is a secured message protected via SPDM session.
 *                                     If session_id is NULL, it is a normal message.
 *                                     If session_id is NOT NULL, it is a secured message.
 * @param  message_size                  size in bytes of the message data buffer.
 * @param  message                      A pointer to a source buffer to store the message.
 * @param  transport_message_size         size in bytes of the transport message data buffer.
 * @param  transport_message             A pointer to a destination buffer to store the transport message.
 *
 * @retval RETURN_SUCCESS               The message is encoded successfully.
 * @retval RETURN_INVALID_PARAMETER     The message is NULL or the message_size is zero.
 **/
libspdm_return_t libspdm_pci_doe_encode_message(const uint32_t *session_id,
                                                size_t message_size, void *message,
                                                size_t *transport_message_size,
                                                void **transport_message)
<span style = "background-color:#dfd">{</span>
    size_t aligned_message_size;
    size_t alignment;
    uint32_t data32;
    pci_doe_data_object_header_t *pci_doe_header;

<span style = "background-color:#dfd">    alignment = LIBSPDM_PCI_DOE_ALIGNMENT;
    aligned_message_size =</span>
        (message_size + (alignment - 1)) &amp; ~(alignment - 1);

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(*transport_message_size &gt;=</span>
                   aligned_message_size + sizeof(pci_doe_data_object_header_t));
<span style = "background-color:#dfd">    if (*transport_message_size &lt;</span>
        aligned_message_size + sizeof(pci_doe_data_object_header_t)) {
<span style = "background-color:#fdd">        *transport_message_size = aligned_message_size +</span>
                                  sizeof(pci_doe_data_object_header_t);
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_BUFFER_TOO_SMALL;</span>
    }
<span style = "background-color:#dfd">    *transport_message_size =</span>
        aligned_message_size + sizeof(pci_doe_data_object_header_t);
<span style = "background-color:#dfd">    *transport_message = (uint8_t *)message - sizeof(pci_doe_data_object_header_t);
    pci_doe_header = *transport_message;
    pci_doe_header-&gt;vendor_id = PCI_DOE_VENDOR_ID_PCISIG;
    if (session_id != NULL) {</span>
<span style = "background-color:#fdd">        pci_doe_header-&gt;data_object_type =</span>
            PCI_DOE_DATA_OBJECT_TYPE_SECURED_SPDM;
<span style = "background-color:#fdd">        data32 = libspdm_read_uint32((const uint8_t *)message);
        LIBSPDM_ASSERT(*session_id == data32);
        if (*session_id != data32) {
            return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
        }
<span style = "background-color:#fdd">    } else {</span>
<span style = "background-color:#dfd">        pci_doe_header-&gt;data_object_type =</span>
            PCI_DOE_DATA_OBJECT_TYPE_SPDM;
    }
<span style = "background-color:#dfd">    pci_doe_header-&gt;reserved = 0;
    if (*transport_message_size &gt; PCI_DOE_MAX_SIZE_IN_BYTE) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_BUFFER_FULL;</span>
<span style = "background-color:#dfd">    } else if (*transport_message_size == PCI_DOE_MAX_SIZE_IN_BYTE) {</span>
<span style = "background-color:#fdd">        pci_doe_header-&gt;length = 0;
    } else {</span>
<span style = "background-color:#dfd">        pci_doe_header-&gt;length =</span>
            (uint32_t)*transport_message_size / sizeof(uint32_t);
    }

<span style = "background-color:#dfd">    libspdm_zero_mem((uint8_t *)message + message_size,</span>
                     aligned_message_size - message_size);
<span style = "background-color:#dfd">    return LIBSPDM_STATUS_SUCCESS;
}</span>

/**
 * Decode a transport message to a normal message or secured message.
 *
 * @param  session_id                    Indicates if it is a secured message protected via SPDM session.
 *                                     If *session_id is NULL, it is a normal message.
 *                                     If *session_id is NOT NULL, it is a secured message.
 * @param  transport_message_size         size in bytes of the transport message data buffer.
 * @param  transport_message             A pointer to a source buffer to store the transport message.
 * @param  message_size                  size in bytes of the message data buffer.
 * @param  message                      A pointer to a destination buffer to store the message.
 *
 * @retval RETURN_SUCCESS               The message is encoded successfully.
 * @retval RETURN_INVALID_PARAMETER     The message is NULL or the message_size is zero.
 **/
libspdm_return_t libspdm_pci_doe_decode_message(uint32_t **session_id,
                                                size_t transport_message_size,
                                                void *transport_message,
                                                size_t *message_size,
                                                void **message)
<span style = "background-color:#dfd">{</span>
    const pci_doe_data_object_header_t *pci_doe_header;
    uint32_t length;

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(transport_message_size &gt; sizeof(pci_doe_data_object_header_t));
    if (transport_message_size &lt;= sizeof(pci_doe_data_object_header_t)) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
    }

<span style = "background-color:#dfd">    pci_doe_header = transport_message;
    if (pci_doe_header-&gt;vendor_id != PCI_DOE_VENDOR_ID_PCISIG) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
    }

<span style = "background-color:#dfd">    switch (pci_doe_header-&gt;data_object_type) {</span>
    case PCI_DOE_DATA_OBJECT_TYPE_SECURED_SPDM:
<span style = "background-color:#fdd">        LIBSPDM_ASSERT(session_id != NULL);
        if (session_id == NULL) {
            return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
        }
<span style = "background-color:#fdd">        if (transport_message_size &lt;=</span>
            sizeof(pci_doe_data_object_header_t) + sizeof(uint32_t)) {
<span style = "background-color:#fdd">            return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
        }
<span style = "background-color:#fdd">        *session_id = (void *)((uint8_t *)transport_message +</span>
                               sizeof(pci_doe_data_object_header_t));
<span style = "background-color:#fdd">        break;</span>
    case PCI_DOE_DATA_OBJECT_TYPE_SPDM:
<span style = "background-color:#dfd">        if (session_id != NULL) {
            *session_id = NULL;</span>
        }
<span style = "background-color:#dfd">        break;</span>
    default:
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_UNSUPPORTED_CAP;</span>
    }

<span style = "background-color:#dfd">    if (pci_doe_header-&gt;reserved != 0) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_MSG_FIELD;</span>
    }
<span style = "background-color:#dfd">    if (pci_doe_header-&gt;length &gt;= PCI_DOE_MAX_SIZE_IN_DW) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
<span style = "background-color:#dfd">    } else if (pci_doe_header-&gt;length == 0) {</span>
<span style = "background-color:#fdd">        length = PCI_DOE_MAX_SIZE_IN_BYTE;
    } else {</span>
<span style = "background-color:#dfd">        length = pci_doe_header-&gt;length * sizeof(uint32_t);</span>
    }
<span style = "background-color:#dfd">    if (length != transport_message_size) {</span>
<span style = "background-color:#fdd">        return LIBSPDM_STATUS_INVALID_MSG_SIZE;</span>
    }

<span style = "background-color:#dfd">    LIBSPDM_ASSERT(((transport_message_size - sizeof(pci_doe_data_object_header_t)) &amp;</span>
                    (LIBSPDM_PCI_DOE_ALIGNMENT - 1)) == 0);

<span style = "background-color:#dfd">    *message_size = transport_message_size - sizeof(pci_doe_data_object_header_t);
    *message = (uint8_t *)transport_message + sizeof(pci_doe_data_object_header_t);
    return LIBSPDM_STATUS_SUCCESS;
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>